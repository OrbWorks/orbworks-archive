#include <SysEvtMgr.h>
#include <FeatureMgr.h>	// Needed to detect ROM versions
#include <DLServer.h>   // Needed to get user name
#include "PCA_res.h"
#include "PCA.h"
#include "PalmChars.h"

char msg[1024];
void Alert(char* msg) {
    FrmCustomAlert(MsgBoxAlert, msg, "", "");
}

bool isOom;
void oom() {
    dword heapFree, heapMax;
    MemHeapFreeBytes(0, &heapFree, &heapMax);
    isOom = true;
    //Alert("Out of memory"); // can't create a form if we are out of memory
    throw CompError();
}

word appVer = 0x0400;
long fullAddr(long addr);

/***********************************************************************
 *   Entry Points
 ***********************************************************************/


/***********************************************************************
 *   Internal Structures
 ***********************************************************************/
typedef	struct {
    word selProg;
    bool showClassic;
    bool debug;
    dword regCode;
    char lastApp[32];
    char memoApp[32];
    char docApp[32];
} PcPreferenceType;


struct PcRegPrefs {
    UInt32 firstUsed;
    word highestVersion;
} regPrefs;

PcPreferenceType prefs;

typedef	struct {
    UInt renamedCategories;	// bitfield	of categories with a different name
    char categoryLabels[dmRecNumCategories][dmCategoryLength];
    Byte categoryUniqIDs[dmRecNumCategories];
    Byte lastUniqID; //	Uniq IDs generated by the device are between
    // 0 - 127.	 Those from	the	PC are 128 - 255.
    Byte reserved1;	// from	the	compiler word aligning things
    Word reserved2;
    CountryType	country; //	Country	the	database (labels) is formatted for
} PcAppInfoType;

typedef	PcAppInfoType* PcAppInfoPtr;


/***********************************************************************
 *	 Global	variables
 ***********************************************************************/
Boolean	HideSecretRecords;
DmOpenRef PcDB;
static FontID AppFontID	= stdFont;
static Boolean SaveBackup =	false;
bool bForceExit	= false;

/***********************************************************************
 *	 Internal Constants
 ***********************************************************************/
#define	appFileCreator				'PCAr'
#define	appPrefID					0x00
#define	appPrefVersionNum			0x01
#define	appDBName					"PCArDB"
#define	appDBType					'PCdb'
// Version Checking	define
#define	version20					0x02000000

/***********************************************************************
 *
 *	 GetObjectPtr
 *
 ***********************************************************************/
VoidPtr	GetObjectPtr(Word objectID) {
    FormPtr	frmP;

    frmP = FrmGetActiveForm();
    return (FrmGetObjectPtr(frmP, FrmGetObjectIndex(frmP,	objectID)));
}

/***********************************************************************
 *
 * FUNCTION: PcAppInfoInit
 *
 * DESCRIPTION:	Create an app info chunk if	missing.  Set
 *		the	strings	to a default.
 *
 * PARAMETERS: db -	open database pointer
 *
 * RETURNS:	0 if successful, errorcode if not
 *
 ***********************************************************************/
Err	PcAppInfoInit(DmOpenRef	dbP) {
    UInt cardNo;
    LocalID	dbID;
    LocalID	appInfoID;
    Handle tempH;
    PcAppInfoPtr appInfoP = NULL;
    PcAppInfoPtr defaultApplicationInfoP;
    Int	loop;

    // If there	isn't an ApplicationInfo make space	for	one
    if (appInfoP ==	NULL) {
        if (DmOpenDatabaseInfo(dbP,	&dbID, NULL, NULL, &cardNo,	NULL))
            return dmErrInvalidParam;

        if (DmDatabaseInfo(cardNo, dbID, NULL, NULL, NULL, NULL, NULL, NULL, NULL, &appInfoID, NULL, NULL, NULL))
            return dmErrInvalidParam;

        tempH =	(Handle)DmNewHandle(dbP, sizeof(PcAppInfoType));
        if (!tempH)	
            return dmErrMemError;

        appInfoID =	MemHandleToLocalID(	tempH);
        DmSetDatabaseInfo(cardNo, dbID,	NULL, NULL,	NULL, NULL,	NULL, NULL,	NULL, &appInfoID, NULL,	NULL, NULL);
        appInfoP = (PcAppInfoPtr)MemHandleLock(tempH);
    }

    // Allocate	& Clear	the	app	info
    defaultApplicationInfoP	= (PcAppInfoPtr)MemPtrNew(sizeof(PcAppInfoType));
    if (defaultApplicationInfoP	== NULL) {
        ErrDisplay("Unable to init PcDB");
        return 1;
    }

    MemSet(	defaultApplicationInfoP, sizeof(PcAppInfoType),	0);
    // Init	the	categories
    for	(loop =	0; loop	< dmRecNumCategories; loop++) {
        defaultApplicationInfoP->categoryUniqIDs[loop] = loop;
    }

    defaultApplicationInfoP->lastUniqID	= dmRecNumCategories - 1;
    // copy	in the defaults	and	free the default app info
    DmWrite(appInfoP, 0, defaultApplicationInfoP,  sizeof(PcAppInfoType));
    MemPtrFree(defaultApplicationInfoP);
    // Unlock
    MemPtrUnlock(appInfoP);
    return 0;
}

static Err RomVersionCompatible(DWord requiredVersion, Word	launchFlags) {
    DWord romVersion;

    // See if we have at least the minimum required	version	of the ROM or later.
    FtrGet(sysFtrCreator, sysFtrNumROMVersion, &romVersion);
    if (romVersion < requiredVersion) {
        if ((launchFlags & (sysAppLaunchFlagNewGlobals | sysAppLaunchFlagUIApp))) {
            // Pilot 1.0 will continuously relaunch	this app unless	we switch to 
            // another safe	one.
            Alert("This	version	of PocketC requires	PalmOS 2.0");
            if (romVersion < version20)	{
                AppLaunchWithCommand(sysFileCDefaultApp, sysAppLaunchCmdNormalLaunch, NULL);
            }
        }
        return sysErrRomIncompatible;
    }
    return 0;
}

/***********************************************************************
 *
 *	Registration Code
 *
 ***********************************************************************/

enum RegStatus { regValid, regOldVersion, regTrial, regTrialExpired, regTrialVeryExpired };
char username[41];

dword GenCode(char* name, dword code) {
    while (*name) {
        code *=	*name++;
        code %=	1000000000;
    }
    return code;
}	

RegStatus RegCheck(dword code, bool bReturnOldVersion) {
#ifdef POCKETC_RETAIL
    return regValid;
#else
    if (!*username) return regValid;
    
    // expired registration codes
    if (bReturnOldVersion) {
    //if (code == GenCode(username, 490155520)) return regOldVersion;
    }
    
    // current and future registration codes
    if (code == GenCode(username, 490155520)) return regValid;
    if (code == GenCode(username, 490155521)) return regValid;
    if (code == GenCode(username, 490155522)) return regValid;
    if (code == GenCode(username, 490155523)) return regValid;

    // trial perioed	
    if (TimGetSeconds()	- regPrefs.firstUsed > 5184000UL) return regTrialVeryExpired;
    if (TimGetSeconds()	- regPrefs.firstUsed > 3888000UL) return regTrialExpired;
    return regTrial;
#endif
}

//#define LIB_DEBUG
#ifdef LIB_DEBUG
#define	wassert(x) { if	(!(x)) Alert("ASSERT failed: " #x);	}
#else
#define	wassert(x) ;
#endif


LocalID	MyFindDatabase(char* name, UInt16& card) {
    UInt16 nCards =	MemNumCards();
    for	(card=0;card<nCards;card++)	{
        LocalID	lid	= DmFindDatabase(card, name);
        if (lid)
            return lid;
    }
    return NULL;
}

struct SizeData	{
    unsigned short size;
    char data[];
};

/***********************************************************************
 *
 *  AboutForm
 *
 ***********************************************************************/
static Boolean AboutFormHandleEvent(EventPtr eventP) {
    Boolean handled = false;
    FormPtr frmP;
    
    if (eventP->eType == frmOpenEvent) {
        frmP = FrmGetActiveForm();
        FrmDrawForm(frmP);
        handled = true;
    }
    
    return handled;
}

/***********************************************************************
 *
 *  RegisterForm
 *
 ***********************************************************************/
ULong preCalcRegCode;

static void RegisterFormInit(FormPtr frmP) {
    char name[43];
    *name = '\"';
    *(name+1) = '\0';
    DlkGetSyncInfo(NULL, NULL, NULL, name+1, NULL, NULL);
    
    if (!*(name+1)) strcpy(name, "copilot");
    else strcat(name, "\"");
    FrmCopyLabel(frmP, RegisterUserNameLabel, name);
}

static Boolean RegisterFormHandleEvent(EventPtr eventP) {
    Boolean handled = false;
    FormPtr frmP = FrmGetActiveForm();
    FieldPtr fp = (FieldPtr)GetObjectPtr(RegisterCodeField);
    char* code;

    char name[41];
    *name = '\0';
    DlkGetSyncInfo(NULL, NULL, NULL, name, NULL, NULL);
    if (!*name) strcpy(name, "copilot");

    switch (eventP->eType) {
        case ctlSelectEvent:
            switch (eventP->data.ctlSelect.controlID) {
                case RegisterOKButton: {
                    RegStatus status = regTrial;
                    code = FldGetTextPtr(fp);
                    if (code) {
                        prefs.regCode = atoi(code);
                        status = RegCheck(prefs.regCode, true);
                    }
                    if (status != regValid && status != regOldVersion) {
                        FrmAlert(InvalidRegAlert);
                    } else if (status == regOldVersion) {
                        FrmAlert(OldVersionRegAlert);
                    } else {
                        FrmAlert(ValidRegAlert);
                    }
                    handled = true;
                    FrmReturnToForm(MainForm);
                    break;
                }

                case RegisterCancelButton:
                    handled = true;
                    FrmReturnToForm(MainForm);
                    break;

                default:
                    break;
            }
            break;

        case frmOpenEvent:
            frmP = FrmGetActiveForm();
            RegisterFormInit(frmP);
            FrmDrawForm (frmP);
            handled = true;
            break;

    }

    return handled;
}

/***********************************************************************
 *
 *  EditorOptionsForm
 *
 ***********************************************************************/

char** pEOList;
vector<char*>* pvAppNames;
#define vAppNames (*pvAppNames)

Int16 StringCompare(void* pa, void* pb, Int32) {
    return strcmp(*(char**)pa, *(char**)pb);
}

static void EOFormInit(FormPtr) {
    // set text of popup
    ControlPtr pCtrl = (ControlPtr)GetObjectPtr(EditorOptionsMemoTrigger);
    if (prefs.memoApp[0])
        CtlSetLabel(pCtrl, prefs.memoApp);
    else
        CtlSetLabel(pCtrl, "<none>");
    
    pCtrl = (ControlPtr)GetObjectPtr(EditorOptionsDocTrigger);
    if (prefs.docApp[0])
        CtlSetLabel(pCtrl, prefs.docApp);
    else
        CtlSetLabel(pCtrl, "<none>");

    // get list of all apps
    DmSearchStateType ss;
    Err err = 0;
    char* name;
    UInt16 card;
    LocalID lid;
    name = new char[32];
    strcpy(name, "<none>");
    vAppNames.add(name);
    err = DmGetNextDatabaseByTypeCreator(true, &ss, 'appl', 0, true, &card, &lid);
    while (err == 0 && lid) {
        name = new char[32];
        if (0 == DmDatabaseInfo(card, lid, name,0,0,0,0,0,0,0,0,0,0)) {
            vAppNames.add(name);
        } else {
            delete name;
        }
        err = DmGetNextDatabaseByTypeCreator(false, &ss, 'appl', 0, true, &card, &lid);
    }

    // sort the list (excluding first element)
    SysQSort(vAppNames.lock() + 1, vAppNames.size() - 1, sizeof(char*), StringCompare, 0);
    
    // set the list choices
    ListPtr pList = (ListPtr)GetObjectPtr(EditorOptionsMemoList);
    LstSetListChoices(pList, vAppNames.lock(), vAppNames.size());
    for (int i=0;i<vAppNames.size();i++) {
        if (!strcmp(vAppNames[i], prefs.memoApp)) {
            LstSetSelection(pList, i);
            LstMakeItemVisible(pList, i);
            break;
        }
    }
    pList = (ListPtr)GetObjectPtr(EditorOptionsDocList);
    LstSetListChoices(pList, vAppNames.lock(), vAppNames.size());
    for (int i=0;i<vAppNames.size();i++) {
        if (!strcmp(vAppNames[i], prefs.docApp)) {
            LstSetSelection(pList, i);
            LstMakeItemVisible(pList, i);
            break;
        }
    }
    
    // set the correct selection
}

static Boolean EOFormHandleEvent(EventPtr eventP) {
    Boolean handled = false;
    FormPtr frmP = FrmGetActiveForm();

    switch (eventP->eType) {
        case ctlSelectEvent:
            switch (eventP->data.ctlSelect.controlID) {
                case EditorOptionsDone: {
                    handled = true;
                    ControlPtr pCtrl = (ControlPtr)GetObjectPtr(EditorOptionsMemoTrigger);
                    strcpy(prefs.memoApp, CtlGetLabel(pCtrl));
                    pCtrl = (ControlPtr)GetObjectPtr(EditorOptionsDocTrigger);
                    strcpy(prefs.docApp, CtlGetLabel(pCtrl));
                    vAppNames.clear();
                    FrmReturnToForm(MainForm);
                    break;
                }
                    
                default:
                    break;
            }
            break;

        case frmOpenEvent:
            EOFormInit(frmP);
            FrmDrawForm (frmP);
            handled = true;
            break;

    }

    return handled;
}

DmOpenRef memoDB;
short FindMemo(char* name);
char lastApplet[32] = {0};
vector<char*>* pvNames;
#define vNames (*pvNames)

void DoFunction(const char* name, bool isfunc);

struct DocHeader {
    //UInt16 version;
    UInt8 crap;
    UInt8 version;
    UInt16 spare;
    UInt32 len;
    UInt16 nRecs;
    UInt16 maxRecSize;
    UInt32 position;
};

// load a doc file into the temporary database, and return the index
// 0 on failure
UInt16 LoadDoc(char* name) {
    UInt16 recID = 0, ret = -1;
    Handle hHdr = NULL, hFlat = NULL, hRec;
    DocHeader* pHdr = NULL;
    unsigned char* pFlat = NULL, * pRec = NULL;
    UInt16 iFlat = 0;

    // open the database
    LocalID lid = DmFindDatabase(0, name);
    assert(lid);
    DmOpenRef docRef = DmOpenDatabase(0, lid, dmModeReadWrite);
    
    // read the header
    hHdr = DmQueryRecord(docRef, 0);
    pHdr = (DocHeader*)MemHandleLock(hHdr);
    
    if (pHdr->version != 1 && pHdr->version != 2)
        goto errorCleanup;
    
    // create the flattened record
    recID = dmMaxRecordIndex;
    hFlat = DmNewRecord(PcDB, &recID, pHdr->len+1);
    if (!hFlat) {
        recID = 0;
        goto errorCleanup;
    }
    
    pFlat = (unsigned char*)MemHandleLock(hFlat);
    
    StrPrintF(msg, "Loading %s...", name);
    DoFunction(msg, false);

    for (short iRec=0;iRec<pHdr->nRecs;iRec++) {
        hRec = DmQueryRecord(docRef, iRec+1);
        pRec = (unsigned char*)MemHandleLock(hRec);
        long len = MemHandleSize(hRec);
        
        if (pHdr->version == 1) {
            // uncompressed
            DmWrite(pFlat, iFlat, pRec, len);
            iFlat += len;
            
        } else {
            long i = 0;
            while (i < len) {
                unsigned char c = pRec[i++];
                
                // space then char
                if (c >= 0xc0) {
                    unsigned char space = ' ';
                    DmWrite(pFlat, iFlat, &space, 1);
                    iFlat++;
                    c = c^0x80;
                }
                // pass-thru
                if (c == 0 || (c >= 0x09 && c <= 0x7f)) {
                    DmWrite(pFlat, iFlat, &c, 1);
                    iFlat++;
                // literal
                } else if (c >= 0x01 && c <= 0x08) {
                    DmWrite(pFlat, iFlat, pRec + i, c);
                    iFlat += c;
                    i += c;
                // copy
                } else {
                    UInt16 offset = (c << 8) | pRec[i++];
                    offset &= 0x3fff;
                    short clen = (offset & 0x07) + 3;
                    offset >>= 3;
                    while (clen--) {
                        DmWrite(pFlat, iFlat, pFlat + iFlat-offset, 1);
                        iFlat++;
                    }
                }
            }
        }
        MemHandleUnlock(hRec);
    }

    // NULL terminate, just in case
    DmSet(pFlat, iFlat, 1, '\0');

    ret = recID;
errorCleanup:
    if (pHdr) MemHandleUnlock(hHdr);
    DmCloseDatabase(docRef);
    if (pFlat) {
        MemHandleUnlock(hFlat);
        DmReleaseRecord(PcDB, recID, true);
    }
    return ret;
}

short FindMemo(char* name) {
    // This assumes that the DB is already open!!!
    Handle h_memo;
    short id = -1;
    char* memo;
    char mname[128];


    UInt numRecs = DmNumRecords(memoDB);
    if (!numRecs) goto cleanUp;
    
    for (UInt i=0;i<numRecs;i++) {
        Word attr; // It's supposed to be a Byte
        ULong uid;
        LocalID lid;

        DmRecordInfo(memoDB, i, &attr, &uid, &lid);
        if (attr & (dmRecAttrDelete | dmRecAttrSecret)) continue; // Record is either secret or trashed
        h_memo = (Handle)DmQueryRecord(memoDB, i);
        memo = (char*)MemHandleLock(h_memo);
        if (*memo=='/' && (*(memo+1)=='/') || *(memo+1)=='$') {
            char* t = memo + 2;
            while (*t && *t!='\n' && (*t=='\t' || *t==' ')) t++;
            if (!*t || *t=='\n') {
                goto closeRec;
            }
            short si=0;
            while (*t && *t!='\n' && si<128) mname[si++] = *t++;
            mname[si--]='\0';
            while (si && (mname[si]==' ' || mname[si]=='\t')) mname[si--]='\0';
            if (!strcmp(name, mname)) {
                id = i;
                MemHandleUnlock(h_memo);
                goto cleanUp;
            }
        }
    closeRec:
        MemHandleUnlock(h_memo);
    }
cleanUp:
    return id;
}

short FindDoc(char* name) {
    short id = -1;
    LocalID lid = DmFindDatabase(0, name);
    UInt32 dbType = 0, dbCreate = 0;
    if (lid) {
        DmDatabaseInfo(0, lid, 0,0,0,0,0,0,0,0,0, &dbType, &dbCreate);
    }
    if (dbType == 'TEXt' && dbCreate == 'REAd') {
        id = LoadDoc(name);
    }
    // TODO: error for incorrect database, or failure to read
    return id;
}

dword heapFree, heapMax, heapStart;
dword ticks;

void DoFunction(const char* name, bool isfunc) {
    if (isfunc)
        StrPrintF(msg, "Compiling %s()...", name);
    else
        strcpy(msg, name);
    FormPtr fp = FrmGetActiveForm();
    Word id = FrmGetObjectIndex(fp, CompileStatusLabel);
    FrmHideObject(fp, id);
    FrmCopyLabel(fp, CompileStatusLabel, msg);
    FrmShowObject(fp, id);

    MemHeapFreeBytes(0, &heapFree, &heapMax);
    StrPrintF(msg, "%ld.%ldKB", (heapStart - heapFree) / 1024, (heapStart - heapFree) % 1024 / 102);
    id = FrmGetObjectIndex(fp, CompileMemUsedLabel);
    FrmHideObject(fp, id);
    FrmCopyLabel(fp, CompileMemUsedLabel, msg);
    FrmShowObject(fp, id);

    StrPrintF(msg, "%ld.%ldKB", heapFree / 1024, heapFree % 1024 / 102);
    id = FrmGetObjectIndex(fp, CompileMemAvailLabel);
    FrmHideObject(fp, id);
    FrmCopyLabel(fp, CompileMemAvailLabel, msg);
    FrmShowObject(fp, id);

    dword secs = TimGetTicks() - ticks;
    secs = secs * 100 / SysTicksPerSecond();
    StrPrintF(msg, "%ld.%ld seconds", secs / 100, secs % 100);
    id = FrmGetObjectIndex(fp, CompileTimeLabel);
    FrmHideObject(fp, id);
    FrmCopyLabel(fp, CompileTimeLabel, msg);
    FrmShowObject(fp, id);
}

class CompileStatus : public ICompileStatus {
public:
    virtual void setStatus(const char* text, bool bFunc) {
        DoFunction(text, bFunc);
    }
};


/***********************************************************************
 *
 *  Compile an Applet
 *
 ***********************************************************************/
// compile dialog data
vector<short> vNumFromList;
void PumpEvents();
extern string g_cid;
bool g_launchedEditor = false;

bool Compile(short sel, bool bDebug) {
    bool gotoError = false;
    bool success = false;
    short errOffset = 0;
    short recID = 0;
    memoDB = NULL;

    RegStatus regStatus = RegCheck(prefs.regCode, false); // don't return OldVersion
    if (regStatus == regTrialExpired) {
        FrmAlert(ExpiredAlert); // It's been used well
    } else if (regStatus == regTrialVeryExpired) {
        FrmAlert(ExpiredPlusAlert); // It's been overused
        FrmGotoForm(MainForm);
        return false;
    }
    
    volatile ULong size = MemHeapSize(0);
    MemHeapFreeBytes(0, &heapStart, &heapMax);
    ticks = TimGetTicks();

    // Launch compile form
    FrmPopupForm(CompileForm);
    PumpEvents();
    
    memoDB = DmOpenDatabaseByTypeCreator('DATA', 'PMem', dmModeReadOnly);
    if (!memoDB)
        memoDB = DmOpenDatabaseByTypeCreator('DATA', sysFileCMemo, dmModeReadOnly);
    if (!memoDB) Alert("No Memo Database!?!");

    ErrorInfo errorInfo;
    CompileStatus status;
    Compiler* comp = new Compiler(&status);
    isOom = false;
    string prcName = vNames[sel];
    int i = prcName.length();
    while (i--) {
        if (prcName[i] == '.')  {
            prcName = prcName.substr(0, i);
            break;
        }
    }
    if (!comp->Compile(vNames[sel], "orbc.sys", (char*)prcName.c_str(), false, true, bDebug ? (char*)"debug" : NULL, NULL, errorInfo)) {
        if (isOom)
            errorInfo.desc = "Out of memory";
        if (errorInfo.file.empty()) {
            StrPrintF(msg, "%s", errorInfo.desc.c_str());
            FrmCustomAlert(CompilerErrorNoFileAlert, msg, "", "");
        } else {
            StrPrintF(msg, "File: %s\nLine: %ld\n%s", errorInfo.file.c_str(), errorInfo.line + 1,
                errorInfo.desc.c_str());
            if (FrmCustomAlert(CompilerErrorAlert, msg, "", ""))
                gotoError = true;
        }
    } else {
        success = true;
    }
    delete comp;
    FrmReturnToForm(0);
    
    // cleanup the temporary data from the database
    word nRecs = DmNumRecords(PcDB);
    while (nRecs--)
        DmRemoveRecord(PcDB, nRecs);
    
    if (gotoError) {
        if (errorInfo.sourceType == srcDoc) {
            GoToParamsPtr gp = (GoToParamsPtr)MemPtrNew(sizeof(GoToParamsType));
            MemSet(gp, sizeof(GoToParamsType), 0);
            MemPtrSetOwner(gp, 0); // The guy at Palm Computing said to do this! :)
            gp->dbID = DmFindDatabase(0, errorInfo.file.c_str());
            gp->matchCustom = errorInfo.offset - 1;
            gp->searchStrLen = -1;
            LocalID id = DmFindDatabase(0, prefs.docApp);
            if (id) {
                SysUIAppSwitch(0, id, sysAppLaunchCmdGoTo, (Ptr)gp);
                g_launchedEditor = true;
            } else {
                Alert("Doc editor not found. Check 'Editor Options'.");
                prefs.selProg = -1;
            }
            
        } else if (errorInfo.sourceType == srcMemo) {
            GoToParamsPtr gp = (GoToParamsPtr)MemPtrNew(sizeof(GoToParamsType));
            MemPtrSetOwner(gp, 0); // The guy at Palm Computing said to do this! :)
            gp->dbID = DmFindDatabase(0, "MemosDB-PMem");
            if (!gp->dbID)
                gp->dbID = DmFindDatabase(0, "MemoDB");
            gp->dbCardNo = 0;
            gp->recordNum = FindMemo((char*)errorInfo.file.c_str());
            gp->matchPos = errorInfo.offset - 1;
            gp->searchStrLen = gp->matchCustom = 1;
            LocalID id = DmFindDatabase(0, prefs.memoApp);
            if (!id) id = DmFindDatabase(0, "Memos-PMem");
            if (!id) id = DmFindDatabase(0, "Memo Pad");

            if (gp->recordNum != (UInt16)-1) {
                SysUIAppSwitch(0, id, sysAppLaunchCmdGoTo, (Ptr)gp);
                g_launchedEditor = true;
            }
        } else {
            Alert("Cannot jump to error for this file type");
        }
    } else {
        prefs.selProg = -1;
    }

    DmCloseDatabase(memoDB);
    memoDB = NULL;
    return success;
}

/***********************************************************************
 *
 *  CompileForm
 *
 ***********************************************************************/

bool hasExt(char* name, char* ext) {
    short nLen = strlen(name);
    short nExt = strlen(ext);
    if (nExt > nLen) return false;
    return (0 == strcmp(name + nLen-nExt, ext));
}

/***********************************************************************
 *
 *  MainForm
 *
 ***********************************************************************/
static void FillSourceList(bool bRedraw) {
    Handle h_memo;
    char* memo;
    char* name;
    short nProgs=0;
    
    vNames.clear();
    
    memoDB = DmOpenDatabaseByTypeCreator('DATA', 'PMem', dmModeReadOnly);
    if (!memoDB)
        memoDB = DmOpenDatabaseByTypeCreator('DATA', sysFileCMemo, dmModeReadOnly);
    if (!memoDB) Alert("No Memo Database!?!");

    UInt numRecs = DmNumRecords(memoDB);
    if (!numRecs) goto memoCleanUp;

    for (short i=0;i<numRecs;i++) {
        Word attr; // It's supposed to be a Byte
        ULong uid;
        LocalID lid;
        DmRecordInfo(memoDB, i, &attr, &uid, &lid);
        if (attr & (dmRecAttrDelete | dmRecAttrSecret)) continue; // Record is either secret or trashed
        h_memo = (Handle)DmQueryRecord(memoDB, i);
        memo = (char*)MemHandleLock(h_memo);
        if (*memo=='/' && *(memo+1)=='/') {
            char* t = memo;
            while (*t && *t!='\n') t++;
            name = (char*)MemPtrNew(t-memo+2);
            ErrFatalDisplayIf(!name, "Error initializing Compile form");
            t = memo+2;
            while (*t && *t!='\n' && (*t=='\t' || *t==' ')) t++;
            if (!*t || *t=='\n') {
                MemPtrFree(name);
                goto closeRec;
            }
            short si=0;
            while (*t && *t!='\n') name[si++] = *t++;
            name[si]='\0';
            if (prefs.showClassic || hasExt(name, ".ocp") || hasExt(name, ".orb")) {
                vNames.add(name);
                vNumFromList.add(i);
            } else {
                MemPtrFree(name);
            }
        }
    closeRec:
        MemHandleUnlock(h_memo);
    }
memoCleanUp:
    DmCloseDatabase(memoDB);

    DmSearchStateType ss;
    LocalID lid;
    UInt card;
    
    if (!DmGetNextDatabaseByTypeCreator(true, &ss, 'TEXt', 'REAd', false, &card, &lid)) {
        do {
            name = new char[32];
            ErrFatalDisplayIf(!name, "Error initializing DOC list");
            DmDatabaseInfo(card, lid, name, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
            if (prefs.showClassic && hasExt(name, ".c") ||
                prefs.showClassic && hasExt(name, ".pc") ||
                hasExt(name, ".ocp") ||
                hasExt(name, ".orb"))
            {
                vNames.add(name);
                short x=-1;
                vNumFromList.add(x);
            } else {
                delete name;
                name = NULL;
            }
            
        } while (!DmGetNextDatabaseByTypeCreator(false, &ss, 'TEXt', 'REAd', false, &card, &lid));
    }

    short iLastApp = -1;
    for (short i=0;i<vNames.size();i++) {
        if (strcmp(vNames[i], prefs.lastApp) == 0) {
            iLastApp = i;
            break;
        }
    }
    
    if (iLastApp != -1) {
        char* prevName = vNames[iLastApp];
        short prevIndex = vNumFromList[iLastApp];
        for (short i=iLastApp; i>0; i--) {
            char* tempName = vNames[i];
            short tempNum = vNumFromList[i];
            vNames[i] = vNames[i-1];
            vNumFromList[i] = vNumFromList[i-1];
        }
        vNames[0] = prevName;
        vNumFromList[0] = prevIndex;
    }

    ListPtr lp = (ListPtr)GetObjectPtr(MainProgsList);
    if (vNames.size()) {
        LstSetListChoices(lp, vNames.lock(), vNames.size());
    } else {
        LstSetListChoices(lp, NULL, 0);
    }
    
    ControlPtr cp = (ControlPtr)GetObjectPtr(MainClassicCheckbox);
    CtlSetValue(cp, prefs.showClassic);
    cp = (ControlPtr)GetObjectPtr(MainDebugCheckbox);
    CtlSetValue(cp, prefs.debug);
    
    if (bRedraw) {
        LstDrawList(lp);
    }
}

static Boolean MainFormDoCommand(Word command) {
    Boolean handled = true;

    switch (command) {
        case OptionsAboutPocketC: {
            FormPtr pFrm = FrmInitForm(AboutForm);
            FrmDoDialog(pFrm);
            FrmDeleteForm(pFrm);
            break;
        }

#ifndef POCKETC_RETAIL
        case OptionsRegister: {
            if (RegCheck(prefs.regCode, true) == regValid) {
                char name[41]; *name='\0';
                DlkGetSyncInfo(NULL, NULL, NULL, name, NULL, NULL);
                if (!*name) strcpy(name, "copilot");
                FrmCustomAlert(AlreadyAlert, name, "", "");
            } else FrmPopupForm(RegisterForm);
            break;
        }
#endif

        case OptionsEditorOptions: {
            FrmPopupForm(EditorOptionsForm);
            break;
        }

        case AppletEditSource: {
            ListPtr lp = (ListPtr)GetObjectPtr(MainProgsList);
            short sel = LstGetSelection(lp);
            if (sel < 0) {
                Alert("No applet selected");
                break;
            }
            prefs.selProg = sel;
            memoDB = DmOpenDatabaseByTypeCreator('DATA', 'PMem', dmModeReadOnly);
            if (!memoDB)
                memoDB = DmOpenDatabaseByTypeCreator('DATA', sysFileCMemo, dmModeReadOnly);
            short id = FindMemo(LstGetSelectionText(lp, sel));
            DmCloseDatabase(memoDB);
            if (id != -1) {
                GoToParamsPtr gp = (GoToParamsPtr)MemPtrNew(sizeof(GoToParamsType));
                MemPtrSetOwner(gp, 0); // The guy at Palm Computing said to do this! :)
                gp->dbID = DmFindDatabase(0, "MemosDB-PMem");
                if (!gp->dbID)
                    gp->dbID = DmFindDatabase(0, "MemoDB");
                gp->dbCardNo = 0;
                gp->recordNum = id;
                gp->matchPos = -1;
                gp->searchStrLen = 0;
                LocalID lid = DmFindDatabase(0, prefs.memoApp);
                if (!lid) lid = DmFindDatabase(0, "Memos-PMem");
                if (!lid) lid = DmFindDatabase(0, "Memo Pad");

                SysUIAppSwitch(0, lid, sysAppLaunchCmdGoTo, (Ptr)gp);
            } else {
                LocalID lid = DmFindDatabase(0, LstGetSelectionText(lp, sel));
                UInt32 dbType = 0, dbCreate = 0;
                if (lid) {
                    DmDatabaseInfo(0, lid, 0,0,0,0,0,0,0,0,0, &dbType, &dbCreate);
                    if (dbType != 'TEXt' || dbCreate != 'REAd')
                        lid = NULL;
                }
                LocalID id = DmFindDatabase(0, prefs.docApp);
                if (lid && id) {
                    GoToParamsPtr gp = (GoToParamsPtr)MemPtrNew(sizeof(GoToParamsType));
                    MemSet(gp, sizeof(GoToParamsType), 0);
                    MemPtrSetOwner(gp, 0); // The guy at Palm Computing said to do this! :)
                    gp->dbID = lid;
                    gp->matchCustom = -1;
                    gp->searchStrLen = 0;
                    SysUIAppSwitch(0, id, sysAppLaunchCmdGoTo, (Ptr)gp);
                } else {
                    if (id)
                        Alert("Source not found");
                    else
                        Alert("Doc editor not found. Check 'Editor Options'.");
                }
            }
            break;
        }
    
        default:
            handled = false;
            break;

    }
    return handled;
}

static Boolean MainFormHandleEvent(EventPtr eventP) {
    Boolean	handled	= false;
    FormPtr	frmP;
    ListPtr	lst;
    ControlPtr pCtrl;
    short j;

    if (HandleResizeEvent(FrmGetActiveFormID(), eventP))
        return true;

    switch (eventP->eType) {
        case ctlSelectEvent:
            switch (eventP->data.ctlSelect.controlID) {
                case MainCompileButton:
                    if (!vNames.size())	break;
                    ListPtr	lp = (ListPtr)GetObjectPtr(MainProgsList);
                    short sel =	LstGetSelection(lp);
                    strncpy(prefs.lastApp, vNames[sel],	32);
                    prefs.lastApp[31] =	0;
                    Compile(sel, prefs.debug);
                    handled	= true;
                    break;
                    
                case MainDebugCheckbox:
                    pCtrl = (ControlPtr)GetObjectPtr(MainDebugCheckbox);
                    prefs.debug = CtlGetValue(pCtrl);
                    break;
                    
                case MainClassicCheckbox:
                    pCtrl = (ControlPtr)GetObjectPtr(MainClassicCheckbox);
                    prefs.showClassic = CtlGetValue(pCtrl);
                    FillSourceList(true);
                    break;
            }
            break;

        case menuEvent:	{
            return MainFormDoCommand(eventP->data.menu.itemID);
            }

        case keyDownEvent:
            lst	= (ListPtr)GetObjectPtr(MainProgsList);
            if (eventP->data.keyDown.chr==pageUpChr) {
                LstScrollList(lst, winUp, 10);
                LstEraseList(lst);
                LstDrawList(lst);
                handled = true;
            } else if (eventP->data.keyDown.chr==pageDownChr) {
                LstScrollList(lst, winDown, 10);
                LstEraseList(lst);
                LstDrawList(lst);
                handled = true;
            }
            break;

        case frmOpenEvent:
            frmP = FrmGetActiveForm();
            FillSourceList(false);
            FrmDrawForm(frmP);
            lst	= (ListPtr)GetObjectPtr(MainProgsList);
            j=LstGetNumberOfItems(lst);
            if (j >	prefs.selProg) {
                if (prefs.selProg <	0) prefs.selProg = j-1;
                LstSetSelection(lst, prefs.selProg);
            }
            handled	= true;
            break;

        case frmCloseEvent:
            lst	= (ListPtr)GetObjectPtr(MainProgsList);
            prefs.selProg =	LstGetSelection(lst);
            vNames.clear();
            break;
    }

    return handled;
}

/***********************************************************************
 *
 * FUNCTION:	AppHandleEvent
 *
 * DESCRIPTION:	This routine loads form	resources and set the event
 *				handler	for	the	form loaded.
 *
 * PARAMETERS:	event  - a pointer to an EventType structure
 *
 * RETURNED:	true if	the	event has handle and should	not	be passed
 *				to a higher	level handler.
 *
 * REVISION	HISTORY:
 *
 ***********************************************************************/
static Boolean AppHandleEvent(EventPtr eventP) {
    Word formId;
    FormPtr	frmP;

    if (eventP->eType == frmLoadEvent) {
        // Load	the	form resource.
        formId = eventP->data.frmLoad.formID;
        frmP = FrmInitForm(formId);
        FrmSetActiveForm(frmP);
        SetFormDIAPolicy(formId);
        // Set the event handler for the form.	The	handler	of the currently
        // active form is called by	FrmHandleEvent each	time is	receives an
        // event.
        switch (formId)	{
            case MainForm:
                FrmSetEventHandler(frmP, MainFormHandleEvent);
                break;
            case CompileForm:
                FrmSetEventHandler(frmP, AboutFormHandleEvent);
                break;
            case AboutForm:
                FrmSetEventHandler(frmP, AboutFormHandleEvent);
                break;
            case RegisterForm:
                FrmSetEventHandler(frmP, RegisterFormHandleEvent);
                break;
            case EditorOptionsForm:
                FrmSetEventHandler(frmP, EOFormHandleEvent);
                break;
            default:
                //ErrNonFatalDisplay("Invalid Form Load	Event");
                break;
        }
        return true;
    }
    return false;
}

/***********************************************************************
 *
 * FUNCTION:	AppEventLoop
 *
 ***********************************************************************/
static void	AppEventLoop()
{
    Word error;
    EventType event;

    do {
        EvtGetEvent(&event,	evtWaitForever);
        if (! SysHandleEvent(&event))
            if (! MenuHandleEvent(0, &event, &error))
                if (! AppHandleEvent(&event))
                    FrmDispatchEvent(&event);
    } while	(event.eType !=	appStopEvent);
}


/***********************************************************************
 *
 * FUNCTION:	PumpEvents
 *
 ***********************************************************************/
void PumpEvents()
{
    Word error;
    EventType event;
    bool lastWasNil = false;

    while (true) {
        EvtGetEvent(&event,	0);
        if (! SysHandleEvent(&event))
            if (! MenuHandleEvent(0, &event, &error))
                if (! AppHandleEvent(&event))
                    FrmDispatchEvent(&event);

        if (event.eType == nilEvent) {
            if (lastWasNil) return;
            lastWasNil = true;
        }
    }
}


/***********************************************************************
 *
 * FUNCTION:     AppStart
 *
 ***********************************************************************/
void randomize(long);
UInt32 romVersion;

static Err AppStart(void)
{
    FtrGet(sysFtrCreator, sysFtrNumROMVersion, &romVersion);
    UInt32 wver = 0;
    
    pvNames	= new vector<char*>(true);
    pvAppNames = new vector<char*>(true);
    
    Err	error= 0;
    UInt mode;
    SystemPreferencesType sysPrefs;
    Word prefsSize;

    *username =	'\0';
    DlkGetSyncInfo(NULL, NULL, NULL, username, NULL, NULL);
    
    // Determine if secert record should be shown.
    PrefGetPreferences(&sysPrefs);
    HideSecretRecords =	sysPrefs.hideSecretRecords;
    if (sysPrefs.hideSecretRecords)	mode = dmModeReadWrite;
    else mode =	dmModeReadWrite	| dmModeShowSecret;
    
    // Find the application's data file.  If it doesn't exist create it.
    PcDB = DmOpenDatabaseByTypeCreator(appDBType, appFileCreator, mode);
    if (!PcDB) {
        error =	DmCreateDatabase(0,	appDBName, appFileCreator, appDBType, false);
        if (error) return error;

        PcDB = DmOpenDatabaseByTypeCreator(appDBType, appFileCreator, mode);
        if (!PcDB) return 1;
    }
    
    // Time	expiration stuff
    prefsSize =	sizeof(regPrefs);
#ifndef	POCKETC_RETAIL
    if (PrefGetAppPreferences('MegN', appPrefID, &regPrefs, &prefsSize, true)==noPreferenceFound || (!regPrefs.firstUsed)) {
        regPrefs.firstUsed = TimGetSeconds();
        regPrefs.highestVersion = appVer;
        PrefSetAppPreferences('MegN', appPrefID, appPrefVersionNum,	&regPrefs, sizeof(regPrefs), true);
    }
#else
    regPrefs.firstUsed = TimGetSeconds();
#endif

    // Read	the	preferences	/ saved-state information.	There is only one
    // version of the Applications preferences so don't	worry about	multiple
    // versions.
    prefsSize =	sizeof(PcPreferenceType);
    MemSet(&prefs, sizeof(PcPreferenceType), 0);
    // We don't	care if	the	prefs aren't found
    short ver =	PrefGetAppPreferences(appFileCreator, appPrefID, &prefs, &prefsSize, true);
    //if (ver == noPreferenceFound || prefsSize	< sizeof(PcPreferenceType))	{
    //	prefs.lastApp[0] = 0;
    //}

    // if memo app is not specified, get it
    if (prefs.memoApp[0] ==	0) {
        DmSearchStateType ss;
        UInt16 card;
        LocalID	lid;
        Err	err	= DmGetNextDatabaseByTypeCreator(true, &ss,	'appl',	'PMem', true, &card, &lid);
        if (err || !lid)
            err	= DmGetNextDatabaseByTypeCreator(true, &ss,	'appl',	'memo', true, &card, &lid);
        if (err	== 0 &&	lid) DmDatabaseInfo(card, lid, prefs.memoApp, 0,0,0,0,0,0,0,0,0,0);
    }
    if (prefs.docApp[0]	== 0) {
        strcpy(prefs.docApp, "<none>");
    }
    
    // Check registration number
    RegStatus status;
    if (regPrefs.highestVersion < appVer) {
        // a newer version was installed, reset the timer so that user can try the new version
        regPrefs.highestVersion = appVer;
        regPrefs.firstUsed = TimGetSeconds();
        PrefSetAppPreferences('MegN', appPrefID, appPrefVersionNum, &regPrefs, sizeof(regPrefs), true);
        
        status = RegCheck(prefs.regCode, true);
        if (status == regOldVersion) {
            FrmAlert(UpgradeRegAlert);
        }
    }
    
    if (DmNumRecords(PcDB) > 0)	{
        for	(short i=DmNumRecords(PcDB)-1; i>=0; i--) {
            DmRemoveRecord(PcDB, i);
        }
    }
    
    InitDIA();

    return error;
}

/***********************************************************************
 *
 * FUNCTION:    AppStop
 *
 ***********************************************************************/
static void AppStop(void) {
    FrmCloseAllForms();
    PrefSetAppPreferences(appFileCreator, appPrefID, appPrefVersionNum,
        &prefs, sizeof(prefs), true);
    DmCloseDatabase(PcDB);

    delete pvNames;
    delete pvAppNames;
    CloseDIA();
}

UInt32 CIDstoi(char* str) {
    UInt32 ret = 0;
    int i = 0;
    char* pret = (char*)&ret;
    
    while (*str && i < 4) {
        pret[i] = str[i];
        i++;
    }
    
    return ret;
}

/***********************************************************************
 * FUNCTION:    PilotMain
 *
 * DESCRIPTION: This is the main entry point for the application.
 *
 * PARAMETERS:  cmd - word value specifying the launch code. 
 *              cmdPB - pointer to a structure that is associated with the launch code. 
 *              launchFlags -  word value providing extra information about the launch.
 *
 * RETURNED:    Result of launch
 *
 ***********************************************************************/
DWord PilotMain(Word cmd, Ptr cmdPBP, Word launchFlags) {
    Err	error;

    error =	RomVersionCompatible(version20,	launchFlags);
    if (error) return error;

    switch (cmd) {
        case sysAppLaunchCmdNormalLaunch:
            error =	AppStart();
            if (error) return error;
            
            //if (prefs.currentForm==FTMain)
            FrmGotoForm(MainForm);
            //else FrmGotoForm(OutputForm);
            AppEventLoop();
            AppStop();
            break;
        case sysAppLaunchCmdSaveData:
            FrmSaveAllForms();
            break;
        case sysAppLaunchCmdSystemReset:
            if (((SysAppLaunchCmdSystemResetType*)cmdPBP)->createDefaultDB)	{
                Handle resH;

                resH = (Handle)DmGet1Resource(sysResTDefaultDB,	sysResIDDefaultDB);
                if (resH) {
                    DmCreateDatabaseFromImage((char*)MemHandleLock(resH));
                    MemHandleUnlock(resH);
                    DmReleaseResource(resH);
                }
            }
            break;
        
        case sysAppLaunchCmdCompile:
        case sysAppLaunchCmdCompileAndReturn: {
            char* fileName = (char*)cmdPBP;
            error =	AppStart();
            if (error) return error;
            // open	compile	form
            FrmGotoForm(MainForm);
            PumpEvents();

            if (cmd == sysAppLaunchCmdCompileAndReturn) {
                // remove the shell CID
                int len = strlen(fileName);
                if (len > 5)
                    fileName[len-5] = '\0';
            }
            // select the specified	file
            bool found = false;
            int	i =	0;
            for	(;i<vNames.size();i++) {
                if (strcmp(vNames[i], fileName) ==	0) {
                    LstSetSelection((ListPtr)GetObjectPtr(MainProgsList), i);
                    found =	true;
                    break;
                }
            }
            bool bCompiled = false;
            // compile
            if (found) {
                strncpy(prefs.lastApp, vNames[i], 32);
                prefs.lastApp[31] =	0;
                bCompiled = Compile(i, false);
                vNames.clear();
                vNumFromList.clear();
            } else {
                Alert("Unable to find specified	file");
            }
            if (cmd == sysAppLaunchCmdCompile || g_launchedEditor) {
                // continue	app	execution
                AppEventLoop();
                AppStop();
            } else {
                char* cmdline = (char*)MemPtrNew(8);
                MemSet(cmdline, 8, 0);
                MemPtrSetOwner(cmdline, 0);
                cmdline[0] = bCompiled ? '1' : '0';
                cmdline[1] = ',';			
                strcat(cmdline + 2, g_cid.c_str());
                char* shell = fileName;
                shell += strlen(shell) + 1;
                DmSearchStateType sst;
                LocalID lid = 0;
                word card = 0;
                dword shellCid = CIDstoi(shell);
                DmGetNextDatabaseByTypeCreator(true, &sst, 'appl', shellCid, true, &card, &lid);
                if (lid) {
                    AppStop();
                    SysUIAppSwitch(card, lid, sysAppLaunchCmdCompileResult, (Ptr)cmdline);
                } else {
                    Alert("Cannot return to shell");
                    // continue	app	execution
                    AppEventLoop();
                    AppStop();
                }
            }
            break;
        }
        case sysAppLaunchCmdNotify:
            HandleResizeNotification(((SysNotifyParamType*)cmdPBP)->notifyType);
            break;
            
        default:
            break;
    }
    return 0;
}
