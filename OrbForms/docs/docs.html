<h1>Language</h1>
<h2>Basics</h2>
<p>The OrbForms language is a simple language based on the
style of C and C++. It is a procedural language with a limited implementation of
objects. The language has a lot of useful features, but becomes extremely
powerful when combined with the event handlers and library provided by the
runtime.</p>
<h3>Project</h3>
<p>An application is defined by a project, created in the IDE. A project consists of a set of resources (forms, bitmaps,
etc.), and source code files. The resources are described in the IDE
documentation.</p>
<h3>Source Files</h3>
<p>A source file contains all the global variables, functions,
and handlers in an application. These items can be spread out over many files.
Unlike traditional C compilers, all the project files are compiled as a set -
all the files are compiled together, in order, as if they were one file. In this
way, the global variables and functions are shared globally across the files.</p>
<h3>A Basic Application</h3>
<p>As a quick introduction to the language, lets dissect a
very simple application. Let's assume you've created an application named
&quot;myApp&quot;. &quot;myApp&quot; has a main form named "myForm" which contains a text field named
"nameField",
and a button named "alertButton". This simple app could look something like
this:</p>

<pre>// a global variable to hold the salutation.
string text;

// the handler for when the app is started
handler myApp.onstart() {
  // load the main form
  myForm.load();
}

// a function to build the text for the alert
string buildText(string name) {
  return &quot;Hello, &quot; + name;
}

// the handler for the button, which displays the alert
handler alertButton.onselect() {
  text = buildText(nameField.text);
  alert(text);
}</pre>

<p>As you can see, there is no main function such as you would see in a C/C++
application. There is no single entry into the application. Instead, all the
code in your application is called by the runtime through handlers. When an
application is started, the first handler to be called is the onstart handler of
you application. Once the handler completes, control is returned to the OrbForms
runtime. The runtime waits for a UI event to occur and calls into the
appropriate handler in your application if one is defined (such as the
alertButton.onselect handler above).</p>

<h3>Keywords</h3>

<p>The keywords are described through the rest of the documentation. As a
reference, they are:<code> if, else, for, while, do, return, break, continue,
switch, case, default, string, int, float, char, bool, void, object, struct,
sizeof, typeof, new, delete, handler, const, enum, include, true, false, null.</code></p>

<p>The following are reserved words, but are not yet used by the language. You
may not use these words as names in your application: <code>static, funcptr, assert,
tassert, debug, debuglog, library, endlibrary.</code></p>

<h3>Comments</h3>
<p>A comment is text in a source file that the compiler
ignores. Comments are used by the developer to explain what the code does in
plain English (or any other languge you prefer). There are two types of
comments: single-line and multi-line. A single line comment begins with two
slashes (//) - everything following the slashes on the current line is a
comment. A multi-line comment starts with /* and ends with */. Multi-line
comments cannot be nested.</p>
<pre>// this is a comment

/* this is a
multi-line comment */</pre>
<pre>/* it is /* not valid */ to nest comments*</pre>

<h2>Variables</h2>
<p>Variables are the items in a program that store data. There
are five basic types of variables in the OrbForms language:</p>
<table border="1">
  <tr>
    <th>Type</th>
    <th>Name</th>
    <th>Example</th>
  </tr>
  <tr>
    <td>integer (32-bit, signed)</td>
    <td><code>int</code></td>
    <td><code>1, 2, 5, -789, 452349</code></td>
  </tr>
  <tr>
    <td>floating point (32-bit)</td>
    <td><code>float</code></td>
    <td><code>-1.2, 3.141592, 5.7e-4</code></td>
  </tr>
  <tr>
    <td>characters (8-bit, signed)</td>
    <td><code>char</code></td>
    <td><code>'a', 'b', '#', '4', 56</code></td>
  </tr>
  <tr>
    <td>strings</td>
    <td><code>string</code></td>
    <td><code>"Bob" "Megan" "Hello"</code></td>
  </tr>
  <tr>
    <td>boolean</td>
    <td><code>bool</code></td>
    <td><code>true, false</code></td>
  </tr>
</table>
<p>Each variable has a name and is of a pre-determined type. Variables are declared like this:<br/>
<i>variable-type name</i>[<i>, name2...</i>]<i>;</i></p>
<p>Here are a few examples:</p>
<pre><B>int</B> myInteger, row, column; // defines three integer variables named &quot;myInteger&quot;, &quot;row&quot;, and &quot;column&quot;
<B>string</B> name;
<B>float</B> pi;
<B>char</B> c, last, first;</pre>
<p>Variables must have names conforming to a few rules: 1. the name must be 31
characters or less. 2. the name may only contain letters, numbers, and the
underscore character (_) 3. the name must not begin with a number. A variable
should not have the same name as a method - although it is legal to do so, this
will prevent the application from being able to call the function from any
location where the variable is visible.</p>
<p>It is also possible to have an <i>array</i> of values. An array is a list of
values that are stored in one variable. Arrays are declared like normal
variables except that the variable name is followed by '<code>[<i>size</i>]</code>'
where <i>size</i> is the number of item that the variable can hold. A
declaration might look like this:</p>
<pre><b>int</b> values[10];
<b>string</b> names[7];</pre>
<p>Of course, arrays and normal variables can be declared
together:</p>
<pre><b>int</b> row, values[10], column;
<b>string</b> name, colors[8];</pre>

<p>You can also give default values to the variables, however
these initial values must be simple literals:</p>
<pre><b>int</b> nine = 9, eight = 8, zero;
<b>string</b> days[7] = { &quot;Sun&quot;, &quot;Mon&quot;, &quot;Tues&quot; };</pre>

<p>In the case of arrays, the initials values must be in
braces and separated by commas. If the number of values in the initializer list
is less than the length of the array, then the uninitialized elements have
default values. For the <code>days</code>
array above, the last 4 members of <code>days</code> are the empty string
("").</p>

<h2>Functions</h2>
<p>A function is a group of statements which is the basic unit of a program. A function has a return type, may have
parameters, and may have local variables. The return type is the type (such as
<code>int</code>) of the value the function returns - when used in an expression, the body of
the function is executed and its return value is used as part of the expression.
(If a function does not return a value, its
type is <code>void</code>, and the function cannot be used in an expression.)&nbsp;&nbsp;&nbsp;&nbsp;<i><br/>
return-type func-name</i>([<i>param-type param-name</i>,...]) { <i>local-variables
statements</i> }</p>

<p>Function names follow the same rules as variable names - 1. the name must be 31
characters or less. 2. the name may only contain letters, numbers, and the
underscore character (_) 3. the name must not begin with a number. All function
names must be unique, and you may not declare a function with the same name as
one of the built-in functions.</p>
<p>Statements are discussed later, but for now, here are a few examples:</p>
<pre>int area(int width, int height) {
   return width * height;
}

float square(float x) {
   return x * x;
}

int five() {
   return 5;
}

void sayHello() {
   alert(&quot;Hello&quot;);
}</pre>

<p><b>Local variables</b> are variables that can only be seen inside a function.
In fact, they only exist while the function is executing. In other words,
function A cannot access the variable inside of function B, and vice versa. When
a function returns, the memory used by the local variables is cleaned up, and
they are no longer accessible. This leads to the
topic of <b>variable scope</b>. All variables have a scope - either global,
local, or struct/object member. You can define a local variable (or parameter)
with the same name as a global variable - when using the variable name inside the function, the local
variable will be accessed/modified, but the global variable will be
inaccessible.</p>
<p><b>Parameters</b> are local variables whose value is provided by the calling
function. In the function above, <code>area</code>, there are two parameters - <code>width</code> and
<code>height</code>. <code>width</code> and <code>height</code> are local variables, but there value is initialized
elsewhere. To invoke area with a width of 5 and a height of 4, you would
type:</p>

<pre>area(5, 4);</pre>

<p>Parameters (except struct and object parameters) are passed by value, which
means that if you pass a variable into a function as a parameter, the function
is not able to modify the original variables. For example:</p>

<pre>void six(int x) {
  x = 6; // only sets the local variable
}

void test() {
  int y = 9;
  six(y);
  // y is still 9
}</pre>

<p>Structs and objects, however, are passed by reference. We'll discuss these
later.</p>

<h2>Expressions</h2>
<p>An expression is something in OrbForms that evalutates to a value. An
expression can be a literal, a variable, a function call (when the function
returns a value), or any combination of these connected by operators.</p>

<p>A <b>literal</b> is any value that is directly entered
into a source file, such as: 5, 5.4, 'j', &quot;hello&quot;.</p>

<p>A value stored in a <b> variable</b> can be accessed by simply typing
its name: (e.g. <code>myInteger</code>). However, if the variable is an array, each value in the
array must be accessed individually by index. The valid indices for an array
with <i>n</i> elements are 0 to <i>n</i>-1. So, an array declared like this:</p>

<pre>string names[4];</pre>

<p>can be accessed like this:</p>

<pre>names[0] = &quot;first name&quot;;
names[1] = &quot;second name&quot;;
names[2] = &quot;third name&quot;;
names[3] = &quot;fourth name&quot;;</pre>

<p>A <b>function call</b> consists of the name of a function followed by
parentheses containing all the parameters for the function. The value of a
function call is the value returned by the function.</p>

<pre>a = area(4, 5);
square(9.2);
clear();
text(20, 30, &quot;Game Over&quot;);</pre>

<p>A function can only be called after it is defined. If you want to call a
function before defining it, you can use a function prototype. A prototype of a
function is a global line (not within another function) which states the return
type, name,
and parameters of a function followed by a semicolon:</p>
<pre>int area(int x, int y);
float square(float); // the use of variable names is optional in a declaration</pre>
<p>These three basic elements can be combined with operators:</p>
<pre>5 + 7 - area(12, 34);
square(5) * pi;
&quot;Hello, &quot; + &quot;World&quot;;</pre>
<p>Of course, function calls can have expressions in them as well:</p>
<pre>area(x+3, y*9);
area(8 * square(4), 7);</pre>
<h3>Assignment</h3>
<p>Variable assignment is actually just another form of expression. The value of
the entire assignment expression is equal to the value being assigned.
Assignment is done in one of two ways--for a normal variable:<br/>
<i>name</i> = <i>expression</i></p>
<p>and for an array:<br/>
<i>name</i>[<i>index-expression</i>] = <i>expression</i></p>
<p>Here are a few examples:</p>
<pre>int myInt, numbers[3];
string myString;
...
myInt = 8;
myString = &quot;Animaniacs&quot;;
numbers[0] = myInt + 5;
numbers[2] = numbers[0] * 8;</pre>
<p>However, since OrbForms is loosely typed, any type of value can be assigned
to any type of variable and the value will be automatically converted:</p>
<pre>myString = 95; // The value of myString is now &quot;95&quot;
numbers[1] = &quot;78&quot;; // The value of numbers[1] is now 78;
numbers[&quot;2&quot;] = &quot;2&quot;; // Another neat trick. numbers[2] is now 2</pre>
<h3>Operators</h3>
<p>The following table gives the list of operators and their associativity in
order of precedence, lowest first. In other words, when two operators are in an
expression, the operator lowest in the table is evaluated first. However, if
part of an expression is enclosed in parens, that part is evaluated first.</p>
<table cellSpacing="1" width="623" border="1">
  <tbody>
    <tr>
      <th vAlign="center">
        <p align="center">Operator</p>
      </th>
      <th vAlign="center">
        <p align="center">Assoc</p>
      </th>
      <th vAlign="center">
        <p align="center">Description</p>
      </th>
    </tr>
    <tr>
      <td vAlign="center">
        <p align="center"><code>=</code></p>
      </td>
      <td vAlign="center">right</td>
      <td vAlign="center">assigns the value of the expression on the right to
        the variable on the left. Evaluates to the expression on the right.</td>
    </tr>
    <tr>
      <td vAlign="center">
        <p align="center"><code>||</code></p>
      </td>
      <td vAlign="center">left</td>
      <td vAlign="center">logical 'or', evaluates to 0 if false, 1 if true</td>
    </tr>
    <tr>
      <td vAlign="center">
        <p align="center"><code>&amp;&amp;</code></p>
      </td>
      <td vAlign="center">left</td>
      <td vAlign="center">logical 'and'</td>
    </tr>
    <tr>
      <td vAlign="center">
        <p align="center"><code>|</code></p>
      </td>
      <td vAlign="center">left</td>
      <td vAlign="center">bitwise 'or'</td>
    </tr>
    <tr>
      <td vAlign="center">
        <p align="center"><code>^</code></p>
      </td>
      <td vAlign="center">left</td>
      <td vAlign="center">bitwise 'xor'</td>
    </tr>
    <tr>
      <td vAlign="center">
        <p align="center"><code>&amp;</code></p>
      </td>
      <td vAlign="center">left</td>
      <td vAlign="center">bitwise 'and'</td>
    </tr>
    <tr>
      <td vAlign="center">
        <p align="center"><code>== != &lt; &lt;= &gt; &gt;=</code></p>
      </td>
      <td vAlign="center">left</td>
      <td vAlign="center">relational operators. == (equal), != (not equal),
        &lt;= (less than or equal), &gt;= (greater than or equal). These
        evaluate to 1 if the expression is true, 0 otherwise</td>
    </tr>
    <tr>
      <td align="center"><code>&lt;&lt; &gt;&gt;</code></td>
      <td>left</td>
      <td>bitwise shift operators. The operands must be <code>int</code> or <code>char</code>.</td>
    </tr>
    <tr>
      <td vAlign="center">
        <p align="center"><code>+ -</code></p>
      </td>
      <td vAlign="center">left</td>
      <td vAlign="center">addition, subtraction (subtraction cannot be used with
        a string argument)</td>
    </tr>
    <tr>
      <td vAlign="center">
        <p align="center"><code>* / %</code></p>
      </td>
      <td vAlign="center">left</td>
      <td vAlign="center">multiplication, division, modulus (cannot be used with
        strings, nor can modulus be used with floats)</td>
    </tr>
    <tr>
      <td vAlign="center">
        <p align="center"><code>- ! ++ - - ~ * [] () &amp; . -&gt; sizeof() typeof()</code></p>
      </td>
      <td vAlign="center">left</td>
      <td vAlign="center">- (negation), ! (logical 'not'), ++ (increment), --
        (decrement), ~ (bitwise neg), [] (array subscript, string character
        accessor), &amp; (address of
        ),&nbsp; . (the struct accessor), and <code>-&gt;</code> (the struct dereference
        accessor). sizeof (size of a type/variable), typeof (type string of a
        type/variable).&nbsp;</td>
    </tr>
  </tbody>
</table>

<h3>Compound Assignment</h3>
<p>To save time and space, you can use compound assignment operators. These
operators perform a binary operation on the left and right side of the
expression, and then assign the value back to the left side. For example:</p>
<pre>x += 2;
myArray[i] *= 3;</pre>
<p>are equivalent to:</p>
<pre>x = x + 2;
myArray[i] = myArray[i] * 3;</pre>
<p>Compound assignment operators have the same precedence as the basic
assignment operator (<code>=</code>). Available compound operators are <code>+=, -=, *=, /=, %=,
^=, |=, &amp;=, &lt;&lt;=, &gt;&gt;=</code>.</p>
<h3>Shortcut Logic</h3>
<p>When using the &amp;&amp; and || operators, the compiler using shortcut
logic, meaning it only evaluates the sub-expression that it needs to in order to
get the correct result. For example:</>

<pre>bool true_func() { return true; }
bool false_func() { return false; }

void test() {
  if (true_func() || false_func()) {
    ...
  }
  if (false_func() &amp;&amp; true_func()) {
    ...
  }
}</pre>

<p>In the first <code>if</code> statement <code>false_func()</code> would not be
called. Since the first half of the || expression is true, the whole expression
must be true so the second half is not evalutated. In the same way, in the
second <code>if</code> expression <code>true_func()</code> is never executed because the compiler knows
that the entire expression is false regardless of the second half.</p>

<h3>String Character Accessor</h3>
<p>To get or set an individual character within a string variable, use <i>stringVariable</i>[<i>index</i>].
The index of the first character is 0. You will produce a runtime error if you
attempt to access a character that is past the end of the string. Example:</p>
<pre>string str = &quot;bob&quot;;
...
alert(str[1]); // Displays the second letter of str
str[1] = 'X'; // changes str from &quot;bob&quot; to &quot;bXb&quot;</pre>
<p><b>Note:</b> the string character accessor cannot be used with literals, nor
can the address of the resulting character be taken. In other words, the following
expressions are not valid: &amp;str[i], &quot;hello&quot;[i]</p>
<h3>Increment / Decrement</h3>
<p>The ++ and -- operators are special in that they must be placed before or
after a variable and modify the value of the variable. The ++ increments the
value of a variable by one, while the -- decrements by one. The caveat is that
if the ++/-- is placed in front of the variable, the expression evaluates to the
value of the variable after it is incremented/decremented. If it is placed after
the variable, the expression evaluates to the variable's previous value.
Example:</p>
<pre>int myInt;
...
myInt = 8;
alert(++myInt); // Displays &quot;9&quot;

myInt = 8;
alert(myInt++); // Displays &quot;8&quot;, but myInt is now 9</pre>
<h3>sizeof() and typeof()</h3>

<p><code>sizeof()</code> and <code>typeof()</code> are operators that give
information about a type. They can be used either on the name of a variable or
the name of a type. <code>sizeof()</code> evaluates to the number of memory values required for
the type - which is 1 for the five basic types and for pointers, but becomes more
interesting when used on structs and objects. <code>typeof()</code> evaluates to a string
describing the memory structure of a type. Some of the built-in functions (such
as DBRecord.read) require these type strings to convert OrbForms structures into
native data to pass to the operating system.</p>

<pre>struct Person {
  string name;
  int age;
};

void test() {
  Person bob;
  int size;
  string type;
  size = sizeof(Person); // size = 2
  size = sizeof(bob); // size = 2
  type = typeof(Person); // type = &quot;si&quot;;
}</pre>

<p><b>Note</b>: When either of these operators&nbsp;is applied to an array
variable, only information about the type is supplied - the size is NOT
multiplied by the number of elements in the array. However, if an array is
contained in a struct/object, the operators return information about the entire
struct/object including the full size of the array.</p>

<h3>Automatic Conversion and Casting</h3>
<p>Just like in assignments statements, automatic conversion takes place in
every part of an expression. If the two arguments to an operator are of
different types, one of the arguments will be promoted to the less strict type. The
promotion order is <code>char</code> to <code>int</code> to <code>float</code> to <code>string</code>. So in the expression:</p>
<pre>&quot;Result is: &quot; + 5;</pre>
<p>The literal 5 is first promoted to a string, and the two strings are
concatenated to &quot;Result is: 5&quot;. This may have some undesirable side effects. For example, if you
want to display an expression and result, you might do
something like this:</p>
<pre>alert(&quot;5 + 7 = &quot; + 5 + 7); // Displays &quot;5 + 7 = 57&quot;</pre>
<p>This probably wasn't the desired outcome. Instead, you would want the
expression evaluated first, then concatenated to the string. The parentheses can
be used to accomplish this:</p>
<pre>alert(&quot;5 + 7 = &quot; + (5 + 7)); // Displays &quot;5 + 7 = 12&quot;</pre>
<p>One problem remains. Suppose you want to find the floating point value of a
fraction of two integer.</p>
<pre>alert(&quot;7 / 5 = &quot; + (7 / 5)); // Displays &quot;7 / 5 = 1&quot;</pre>
<p>This output is because both arguments are integers, so the result is also an
integer. To solve this, we can cast one of them to a float:</p>
<pre>alert(&quot;7 / 5 = &quot; + ((float)7 / 5)); // Displays &quot; 7 / 5 = 1.4&quot;</pre>
<p>This forces the integer 7 to a floating point number before dividing it by 5.</p>

<h2>Constants and Enumerations</h2>

<p>It is often useful to give names to important constants. This makes source
code more readable. You can do this by defining a constant using the <code>const</code>
keyword, or by creating an enumeration using the <code>enum</code> keyword. A
constant is defined the same way a variable is, but begins with the <code>const</code>
keyword. A constant can only be created for the five simple types. For example:</p>

<pre>const float pi = 3.141592;
const string version = &quot;1.0&quot;;</pre>

<p>Enumerations are a way of creating a group of related integer contants. Each
enumeration name is put in a list, and can be given an explicit value (such a
four, below). If an explicit value is not given, the compiler will provide a
default value - the value for each name is 1 greater than the previous name, and
0 for the first name. To clarify:</p>

<pre>enum { zero, one, two, four = 4, five };</pre>

<p><b>Note</b>: constants and enumerations are treated by the compiler at a low level.
Because of this, whenever the compiler sees
the name of a constant or enum, it treats it as if it was the defined value. If
the programmer attempts to define a variable or function with the same name as a
constant/enum, the compiler will give an error saying that an identifier was
expected.&nbsp;</p>

<h2>Statements</h2>
<p>Statements are the individual parts that make up the body of a function. The
following are the available statements:</p>
<table border="1">
  <tbody>
    <tr>
      <th>Statement</th>
      <th>Description</th>
    </tr>
    <tr>
      <td><code>return;</code></td>
      <td>Returns immediately from the current function. If the function has a
        return type other than <code>void</code>, the next form of return must be used.</td>
    </tr>
    <tr>
      <td><code>return <i>expr</i>;</code></td>
      <td>Returns immediately from the current function, returning the value of
        the expression <i>expr</i>. This may only be used if the function is
        declared with a return type other than <code>void</code>.</td>
    </tr>
    <tr>
      <td><code>if (<i>expr</i>) <i>stmt</i></code></td>
      <td>Evaluates the expression <i>expr</i>, if its result is true (non-zero,
        non-null pointer, or non-empty string), the statement <i>stmt</i> is executed, otherwise <i>stmt</i>
        is skipped, and execution continues</td>
    </tr>
    <tr>
      <td><code>if (<i>expr</i>) <i>stmtA</i><br/>
        else <i>stmtB</i></code></td>
      <td>Evaluates the expression <i>expr</i>, if its result is true (non-zero,
        non-null pointer,
        or non-empty string), the statement <i>stmtA</i> is executed, otherwise <i>stmtB</i>
        is executed</td>
    </tr>
    <tr>
      <td><code>while (<i>expr</i>) <i>stmt</i></code></td>
      <td>The expression <i>expr</i> is evaluated. If it is true (non-zero,
        non-null pointer, or
        non-empty string), <i>stmt</i> is executed. The loop then begin again,
        evaluating <i>expr</i> and executing <i>stmt</i> until <i>expr</i> is no
        longer true. This means that <i>stmt</i> will never execute if <i>expr</i>
        is initially false</td>
    </tr>
    <tr>
      <td><code>do <i>stmt</i><br/>
        while (<i>expr</i>)</code></td>
      <td>The same as <code>while</code> except that the statement <i>stmt</i>
        is executed before <i>expr</i> is evaluated. This guarantees that <i>stmt</i>
        will executed at least once</td>
    </tr>
    <tr>
      <td><code>for (<i>init</i>;<i>cond</i>;<i>iter</i>)<br/>
        <i>stmt</i></code></td>
      <td>The initializer expression <i>init</i> is first evaluated. The
        condition expression <i>cond</i> is evaluated. If it is true, <i>stmt</i>
        is executed and the iterator expression <i>iter</i> is evaluated
        continuing the loop, otherwise the the <code>for</code> loop ends. Note:
        <i>init</i> is evaluated only once.</td>
    </tr>
    <tr>
      <td><code>break;</code></td>
      <td>Immediately exits from the directly enclosing <code>while/do/for</code>
        loop or <code>switch</code> statement..</td>
    </tr>
    <tr>
      <td><code>continue;</code></td>
      <td>Immediately jumps to the beginning of the the directly enclosing <code>while/do/for</code>
        loop. In a <code>for</code> loop, the <i>iter</i> expression is
        evaluated, followed by the <i>cond</i> expression and possibly the <i>stmt</i>.
        In a <code>while</code>
        loop, the <i>cond</i> expression is evaluated again, and possibly the <i>stmt</i>.</td>
    </tr>
    <tr>
      <td><code>switch (<i>expr</i>)<br/>
        { stmts }</code></td>
      <td>Evaluates the expression <i>expr</i>. If <i>stmts</i> contains a <code>case</code>
        statement with a matching value, the code immediately following the <code>case</code>
        statement is executed until either a <code>break</code> statement or the
        end of the <code>switch</code> statement is reached. If no matching <code>case</code>
        statement is found and a <code>default</code> statement exists in the <code>switch</code>,
        the code immediately following the <code>default</code> statement is
        executed until either a <code>break</code> statement or the end of the <code>switch</code>
        statement is reached. If no case statement matches the <i>expr</i>, and
        no <code>default</code> statement is present, everything in the <code>switch</code>
        statement is skipped, and execution continues after the final closing
        brace. <i>expr</i> must evaluate to an <code>int</code>, <code>char</code>, or <code>string</code>.</td>
    </tr>
    <tr>
      <td><code>case <i>constant</i>:</code></td>
      <td>
        <p align="left">A marker within a <code>switch</code> statement. The <i>constant</i>
        must be either a <code>char</code> (<code>case 'a':</code>), an <code>int</code>
        (<code>case 3:</code>), or a <code>string</code> (<code>case
        &quot;apple&quot;:</code>) If the <i>constant</i> matches the <i>expr</i>
        in the <code>switch</code> statement, then the code immediately
        following this marker is run, until a <code>break</code> statement or
        the end of the <code>switch</code> statement is reached.</p>
      </td>
    </tr>
    <tr>
      <td><code>default:</code></td>
      <td>An optional marker within a <code>switch</code> statement. If none of
        the <code>case</code>s in the <code>switch</code> statement match the <code>switch</code>
        <i>expr</i>, the code immediately following this marker is executed,
        until a <code>break</code> statement or the end of the <code>switch</code>
        statement is reached.</td>
    </tr>
    <tr>
      <td><code>{ <i>statements</i> }</code></td>
      <td>A brace followed by a list of statements, followed by another brace is
        considered a single statement</td>
    </tr>
    <tr>
      <td><code><i>expression</i>;</code></td>
      <td>An expression followed by a semicolon is also considered to be a
        statement</td>
    </tr>
  </tbody>
</table>
<h3>
Statement Examples</h3>
<p><b>return</b></p>
<p>Let's visit a previous example function to see how return works.</p>
<pre>int five() {
   return 5;
}</pre>
<p>Since the return value of the function <i>five</i> is always 5, we can use
the function any place we would normally put the literal 5.</p>
<pre>alert(&quot;Five is &quot; + five()); // Prints &quot;Five is 5&quot;</pre>
<p>Also, since <code>return</code> causes the function to exit immediately, we
could do this:</p>
<pre>int five() {
   return 5;
   alert(&quot;This won't display&quot;);
}</pre>
<p>and we would have the same effect.</p>
<p><b>if</b></p>
<pre>void lessThan5(int x) {
   if (x &lt; 5)
      alert(&quot;Less than five&quot;);
   alert(&quot;Hello&quot;);
}</pre>
<p>If this function is called with a number less than 5, &quot;Less than
five&quot; will be displayed followed by the word &quot;Hello&quot;, otherwise,
only the word &quot;Hello&quot; is displayed.</p>
<p><b>if ... else</b></p>
<pre>void lessThan5(int x) {
   if (x &lt; 5)
      alert(&quot;Less than five&quot;);
   else
      alert(&quot;Greater than or equal to five&quot;);
}</pre>
<p>If this function is called with a parameter less than 5, &quot;Less than
five&quot; is displayed, otherwise &quot;Greater than or equal to five&quot; is
displayed.</p>
<p><b>while</b></p>
<pre>void count() {
   int x;

   x = 5;
   while (x &gt; 0) {
      alert(x);
      x = x - 1;
   }
}</pre>
<p>This bit of code will display the numbers from 5 to 1 counting backwards.
Notice that braces were placed around the two lines of code in the <code>while</code>
loop to make them act as a single statement.</p>
<p><b>do ... while</b></p>
<pre>void count() {
   int x;

   x = 6;
   do {
      x = x - 1; // could also be x--
      alert(x);
   } while (x &gt; 0);
}</pre>
<p>This bit of code (similar to the previous example) will display the numbers
from 5 to <b>0</b> counting backwards. The zero is displayed in this case because
the expression <code>x &gt; 0</code> is not evaluated until after the loop</p>
<p><b>for</b></p>
<pre>void output() {
   string list[4];
   int index;

   list[0] = &quot;Zero&quot;;
   list[1] = &quot;One&quot;;
   list[2] = &quot;Two&quot;;
   list[3] = &quot;Three&quot;;

   for (index = 0 ; index &lt; 4 ; index++)
      alert(list[index]);
}</pre>
<p>This example will display  "Zero", "One, "Two", "Three". When we dissect it we
see that the array <i>list</i> is initialized first. We then reach the <code>for</code>
loop. First, the initializer is evaluated, setting index to 0. Next, the
condition is evaluated <code>index &lt; 4</code>, which is true, so the body of
the loop executes, displaying &quot;Zero&quot;. The iterator expression is then
evaluated, increasing <i>index</i> by one. This continues until <i>index</i> is
equal to 4, at which point the loop exits without executing the body again.</p>
<p><b>break</b></p>
<pre>void count() {
   int x;

   x = 5;
   while (x &gt; 0) {
      if (x == 1)
         break;
      alert(x);
      x = x - 1;
   }
}</pre>
<p>In this slightly more complex piece of code, the counting goes on as it
normally would, displaying &quot;5&quot;, &quot;4&quot;, &quot;3&quot;, 2&quot;. However, when <i>x</i> reaches 1,
<code>break</code> is executed, breaking out of the <code>while</code> loop
early, before the 1 gets displayed.</p>
<p><b>continue</b></p>
<pre>void count() {
   int x;

   x = 6;
   while (x &gt; 1) {
      x--; // Do the subtraction first
      if (x == 3)
         continue;
      alert(x);
   }
}</pre>
<p>In this clearly contrived example, the output is &quot;5421&quot;. When <i>x</i>
reaches 3, the <code>continue</code> is executed, jumping to the
beginning of the loop, skipping over the <i>alert</i>.</p>
<p><b>switch, case, default</b></p>
<pre>void which_number(int x) {
   switch (x) {
      case 1:
         alert(&quot;x == 1\n&quot;);
         break;
      case 2:
      case 3:
         alert(&quot;x == 2 or x == 3\n&quot;);
         break;
      case 8:
         alert(&quot;x == 8\n&quot;);
      case 10:
         alert(&quot;x == 8 or x == 10\n&quot;);
         break;
      default:
         alert(&quot;x is not 1,2,3,8, or 10\n&quot;);
   }
}</pre>
<p>The <i>which_number</i> function is passed a value, and will display a fact
or two about it. If the value is 1, <code>case 1</code> is executed and <code>break</code>s
to the end of the <code>switch</code>. If the value is 2 or 3, the code
following <code>case 3:</code> is executed. If the value is 8, both
&quot;x=8&quot; and &quot;x=8 or x=10&quot; is displayed because there is no <code>break</code>
before <code>case 10:</code>, this is called &quot;fall-through&quot;. If none of the cases
match the the value of <i>x</i>, the code following <code>default:</code> is executed.</p>

<h2>Pointers</h2>
<p><strong>Note:</strong> Pointers are an advanced topic, which should be dealt
with after the user is familiar with all the other programming concepts.</p>
<p>All variables are stored at some address in memory. A pointer is a variable
which holds the address of another variable - using the pointer the value of the
original variable can be indirectly accessed (a process called
&quot;dereferencing&quot;). A pointer can be used with only one value type (<code>int</code>,
<code>string</code>, <code>struct</code>, etc.) - for example an integer pointer can only be used to
access an integer. A pointer is declared in the same way as a normal variable
with the addition of an asterisk (*) after the type name.</p>
<p>There are two primary operators which are used with pointers, * and &amp;.
The * operator dereferences the pointer. A dereferenced pointer acts just like
the data to which it points. The &amp; operator returns the address of a given
variable. To illustrate:</p>
<pre>int* p, q; // <b>Note:</b> unlike in C/C++, this declares p and q to <b>BOTH</b> be pointers
int i;

void test() {
  i = 5;
  p = &amp;i;    // Assign the address of 'i' to the pointer 'p'
             // now, typing '*p' is the same as typing 'i'
  alert(*p); // Display the value of 'i'
  *p = 7;    // Assign 7 to 'i'
  q = p;     // Assign the value of 'p', which is the address of 'i', to 'q'
             // now, typing '*q' is the also the same as typing 'i'

  // Things not to do
  p = 8;     // BAD! Don't assign a literal value to a pointer
  *i = 9;    // BAD! Don't try to dereference a non-pointer
}</pre>

<p>When initially declared, the pointers will have the value <code>null</code> (which is
equivalent to 0), which means they point to nothing and cannot be dereferenced.</p>

<h3>Pointers and arrays</h3>
<p>Pointers and arrays are fairly similar. Pointers can use the [] operator, and an
array variable (when not used with []) results in the address of the first
element. For example:</p>
<pre>int array[5];
int* p;

void test() {
  p = array; // Assign the address of the first element of
             // 'array' to 'p'
  *p = 7;    // Assign 7 to array[0]
  p[1] = 8;  // Assign 8 to array[1]
}</pre>
<p>This enables the pointers to arrays to be passed as function parameters. This
also allows the user to implement their own version of two-dimensional arrays
(multi-dimensional arrays will be implemented in a future version). By creating an array of pointers, each of which is a pointer to an array (or
part of one), a two-dimensional array can be simulated.</p>
<pre>int array[100];
int* twod[10]; // after init(), this can be treated
               // like at 10x10 matrix

void init() {
  int i;
  for (i=0;i&lt;10;i++)
    twod[i]=array + i*10; // Pointer arithmetic
}

void test() {
  int x, y;
  init();
  for (x=0;x&lt;10;x++)
    for (y=0;y&lt;10;y++)
      twod[x][y]=x * y; // Sets array[x*10 + y] = x*y
}</pre>

<h3>Pointer arithmetic</h3>
<p>Pointer values can used in a limited number of expression. You can add and
subtract from a pointer (and, thus, can use the increment and decrement
operators as well). When you add 1 to a pointer, the pointer points to the next
value in memory. Similarly, when you subtract 1 from a pointer, the pointer
points to the previous value in memory. When you add to or subtract from a
pointer to a structure/object, the pointer is changed by the number of
structures specified, rather than the number of memory values (see example
below). Caution should be used when using
pointer arithmetic, because dereferencing an invalid memory location will cause
an error in the applet.</p>

<pre>struct Person {
  string name;
  int age;
};
...
Person people[10];
Person* pPerson;
pPerson = &amp;people[4]; // pPerson now points to the 4th person
pPerson++;            // pPerson now points to the 5th person</pre>

<h3>Dynamically allocating memory (new and delete)</h3>
<p>The OrbForms language allows you to dynamically allocate memory at runtime.
Two of the most common uses of this are allocating an array whose length cannot
be determined before the program is run, and creating structures and objects
(discussed soon).</p>

<p>To allocate a new block of memory, use the new keyword. The new keyword takes
the name of the type to allocate and returns a pointer to the allocated memory
(or null if the allocation fails). For example:</p>

<pre>int* pi;
string* ps;
pi = new int;
ps = new string;
*pi = 6;
*ps = &quot;Hello&quot;;</pre>

<p>The new keyword can also create arrays by specifying the number of desired
elements in brackets after the type name:</p>

<pre>int count = 10;
int* parray;
string* psarray;
parray = new int[10]; // allocate an array of 10 integers
psarray = new string[count * 2]; // allocates count*2 strings
if (parray != null) { // since dynamic memory may run out,
  parray[3] = 45;     // you should check that new succeeded
}                     // before using the pointer!
if (psarray) { // this is the same as (psarray != null)
  psarray[12] = &quot;twelve&quot;;
}</pre>

<p>Once the memory is no longer needed, it must be freed using the delete
operator. The delete operator takes a pointer to memory previously allocated by
new. The pointer could have been allocated either as a single value, or as an
array - if the pointer is null, it will safely do nothing.</p>

<pre>delete pi; // delete the integer pointed to by pi
delete parray; // deletes the entire array pointed to by parray
delete null; // does nothing</pre>

<p><b>Note:</b> The runtime also provides two methods for dealing with less
structured memory allocations: malloct, and free.&nbsp;&nbsp;</p>

<h2>Structures</h2>
<p>A structure is a user defined data type that is a
collection of other data types. For example, a Person data type can be defined
as a string containing the person's name, and an integer representing the
person's age like this:</p>

<pre>struct Person {
  string name;
  int age;
};</pre>

<p>After being declared, Person can be used like the built-in data types (e.g.
int, string). To access the data in a structure, use the dot (.) operator like this:</p>

<pre>Person bob; // create a Person variable named 'bob'
bob.name = &quot;Bob&quot;; // assign &quot;Bob&quot; to the name member of 'bob'
bob.age = 26;</pre>

<p>When using a pointer to a struct, you must use the <code>-&gt;</code>
operator, rather than the <code>.</code> operator, to access the data in the structure, like this:</p>

<pre>Person* pBob; // create a Person pointer name 'pBob'
pBob = new Person; // allocate a new Person object, and assign the address to 'pBob'
pBob-&gt;name = &quot;Bob&quot;; // set the name member of the Person that 'pBob' points to
pBob-&gt;age = 18;</pre>

<p>Structs may also contain other structs (or objects) as members. When a struct
contains another struct, multiple <code>.</code> operators must be used. For
example:</p>

<pre>struct City {
  int population;
  Person mayor;
};
City hudson;
...
hudson.mayor.age++; // happy birthday</pre>

<p>Structs can be initialized like other data types, but must
be enclosed in braces and each member must be initialized in the order in which
they were declared, like this:</p>

<pre>Person bob = { &quot;Bob&quot;, 72 };
City hudson = { 45000, { &quot;Mayor John&quot;, 48 } };</pre>

<p>Stuctures can be copied just like other variables, by using the assignment operator (=):</p>

<pre>Person bob = { &quot;Bob&quot;, 54 }, andy = { &quot;Andy&quot;, 32 };
bob = andy; // copies all the data from 'andy' to 'bob'
alert(bob.name); // displays &quot;Andy&quot;</pre>

<p>Unlike other variable types, structure and object parameters are passed by
reference. When a structure is passed to a function, the entire structure is not
copied. Instead, when the structure parameter is accessed, the original
structure is accessed, not a local copy. For example:</p>

<pre>struct Person {
  string name;
}

void bob(Person person) {
  person.name = &quot;bob&quot;; // this affects the original varaible 'andy'
}

void test() {
  Person andy = { &quot;Andy&quot; };
  bob(andy); // pass a reference to 'andy'
  // andy.name is now &quot;Bob&quot;
}</pre>

<h2>Objects</h2>
<p>An object is a structure with functions defined that
operate on it. These functions are called methods. An object is declared in the same way as a structure, with
the addition of method declarations. Method declarations are identical to
function declarations, but are inside the object. The following block of code
declares a new object type called MyObject:</p>

<pre>object MyObject {
  int data;
  int add(int x);
};</pre>

<p>An instance of an object is then created in the same way as a struct, by
declaring a variable of the new object's type, and the objects members can be
accessed like struct members:</p>

<pre>MyObject mine; // create a MyObject variable named 'mine'
mine.data = 4; // assign 4 to the data member of 'mine'</pre>

<h3>Methods</h3>
<p>A method is defined like a function, but with the name of
the object type before the method name, like this:</p>

<pre>int MyObject.add(int x) {
  data += x;
  return data;
}</pre>

<p>Within the context of a method, all the members of the object
can be accessed as if they are local variables, like <i>data</i> above. However,
if a local variable is defined with the same name as an object member, you must
use <code>this</code>, below, to access the member. Given the above definition of
<code>MyObject.add</code>:</p>
<pre>MyObject mine = { 4 }; // initialize mine.data to 4
mine.add(3); // adds 3 to mine.data</pre>

<p>Just as with pointers to structures, accessing members and methods of an object through a pointer
must be done with the <code>-&gt;</code> operator</p>

<pre>MyObject* pMine;
pMine = new MyObject; // allocate a new object
pMine-&gt;data = 9;
pMine-&gt;add(4); // use the -&gt; to call methods as well</pre>

<h3>this</h3>
<p>Within an object method, <code>this</code> is a special keyword that
represents the current object. (Unlike in C++, <ocde>this</code> is a reference to the object
rather than a pointer). this can be used to pass the current object to another
function as a parameter, but is not required to access the members or methods of
the object.</p>

<pre>void doSomething(MyObject myo) { }

int MyObject.add(int x) {
  doSomething(this); // call the doSomething method, using the current object as a parameter
  return data;
}</pre>

<p><code>this</code> may also be used to access an object member that is hidden by a local
variable:</p>

<pre>int MyObject.add(int x) {
  int data; // local variable
  data = 5; // changes the value of the local variable, not the member
  this.data += x; // adds x to the member 'data'
  return this.data;
}</pre>

<h3>_init, _destroy, _copy</h3>
<p>There are three special methods that can be defined for an
object. Calls to these methods are generated automatically by the compiler, and
they cannot be called directly by the developer. These methods are optional, and
default implementations will be generated by the compiler if they are required
and the developer has not defined them.</p>

<p><b>void _init()</b></p>
<p>This method is called automatically when an object is being
created. When an object is created with the <code>new</code> keyword, this method is called
upon successful creation. If the object is a global variable, this method is
called before the application starts. If the object is a local variable, this
method is called upon entry into the containing function. If the object contains
other objects with _init defined, those objects are initialized before the
containing object.</p>

<p><b>void _destroy()</b></p>
<p>This method is called automatically when an object is being
deleted. When an object is deleted with the <code>delete</code> keyword, this method is
called upon successful deletion. If the object is a global variable, this method
is called after the application exits. If the object is a local variable, this
method is called just before the containing function returns. If the object
contains other objects with _destroy defined, those objects are destroyed after
the containing object.</p>

<p><b>void _copy(<i>object-type</i> source)</b></p>
<p>This method is called automatically when an object is being
copied - when an object is assigned to another object or when an object is
returned from a function. If this method is not defined, the compiler may
generate one (if it needs to do so). If the method is defined, the developer is
required to manually copy all the important members. When defined, an assignment
such as a = b would generate a call which would look like a._copy(b).</p>

<p>Here is an example to demonstrate how these methods work:</p>

<pre>object Person {
  _init();
  _destroy();
  _copy(Person);
  string name;
  int age;
};

void test() {
  Person a, b; // allocates stack space, calls a._init() and b._init()
  Person* p;
  
  a.name = &quot;Jon&quot;;
  b = a; // generates call to b._copy(a)
  p = new Person; // allocates heap space, calls p-&gt;_init()
  *p = a; // generates call to p-&gt;_copy(a)
  delete p; // calls p-&gt;_destroy(), frees heap space
} // calls b._destroy() and a._destroy()</pre>

<h1>Enabling User Interfaces</h1>

<h2>Event Handlers</h2>
<p>An OrbForms application responds to user interaction through event handlers.
Whenever a button is pressed, a form is opened, or dozens of other things
happen, an event is generated. If the application has defined a handler for that
event, that handler is executed.</p>
<p>For each user interface object (form, button, etc.) in your application, the
IDE automatically creates an object to represent it. Each type of control has a
corresponding object type - a button is of type UIButton, form is UIForm, etc.
See the API documentation for more details and supported events. For example,
if you created a button named 'helloButton', the compiler would create a
UIButton object named helloButton.</p>

<p>An event handler is similar to an object method, but is defined for an
<i>instance</i> of a UI object. A handler does not have a return value, and takes no
parameters - the event information can be retrieved using the Event object, see
API documentation for details. When one of the events occurs that is supported
by the object, the handler is executed. Using helloButton as an example, you
could define a handler for the onselect event (which is the only event supported
by a button) like this:</p>

<pre>handler helloButton.onselect() {
  alert(&quot;You pressed the 'hello' button!&quot;);
}</pre>

<p>Just as with object methods, event handlers can access the UI object's
members directly (like the x and y coordinate):</p>

<pre>handler helloButton.onselect() {
  string coord;
  coord = &quot;(&quot; + x + &quot;,&quot; + y + &quot;)&quot;; // x and y provided by UIButton object
  alert(&quot;helloButton is at &quot; + coord);
}</pre>

<p>Unlike object methods, handlers cannot be called directly - only the runtime
can call them.</p>

<h2>Creating and Using Gadgets</h2>
<p>The Palm OS provides many useful types of UI controls, such as buttons, lists,
and text fields. However, many times an application needs to interact with the
user in a way these controls to do not provide. For example, a chart control
would be very useful for displaying collected data and a graph control would
make displaying trends easy. Using gadgets it is possible to create these and
many other controls that can then be reused in multiple forms or applications.</p>

<p>A gadget is defined by creating an object which provides some or all the default
event handlers. A gadget must have a UIGadget as its first member, and must
define methods to handle one or more of the gadget events (onopen, onclose,
ondraw, onpendown, onpenmove, onpenup). These methods have the same name as the
event handler, take no parameters, and return nothing (<code>void</code>). For example:</p>

<pre>object Chart {
  UIGadget gadget;
  void onopen();
  void onclose();
  void ondraw();
  
  Draw draw;
};

void Chart.onopen() {
  draw.attachGadget(gadget); // a draw object can attach to a gadget when it opens
}

void Chart.onclose() {
}

void Chart.ondraw() {
  draw.begin();
  draw.line(clrFG, 0, 0, gadget.w-1, gadget.h-1);
  draw.end();
}</pre>

<p>When these methods are defined, they are used as the default event handlers
for gadgets of this type. The UIGadget object (called 'gadget' above) is used to
access the location, size, and visibility properties of the gadget (see ondraw
above). </p>

<p>To use a gadget, create an instance of one on a form using the IDE. After a
Chart gadget is added to a form, the IDE automatically creates a Chart object
using the name you have specified, myChart for example. To customize this
object, you may override the default handlers that the gadget type provides.
However, if you define a handler for myChart, the default handler will not be
called unless you explicitly call it. For example: </p>

<pre>handler myChart.ondraw() {
  ondraw(); // call the default Chart supplies
  draw.begin();
  draw.line(clrFG, gadget.w-1, 0, 0, gadget.h-1);// draw an intersecting line
  draw.end();
}</pre>

