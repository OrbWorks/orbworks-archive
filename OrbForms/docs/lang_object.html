<p>An object is a structure with functions defined that
operate on it. These functions are called methods. An object is declared in the same way as a structure, with
the addition of method declarations. Method declarations are identical to
function declarations, but are inside the object. The following block of code
declares a new object type called MyObject:</p>

<pre>object MyObject {
  int data;
  int add(int x);
};</pre>

<p>An instance of an object is then created in the same way as a struct, by
declaring a variable of the new object's type, and the object's members can be
accessed like struct members:</p>

<pre>MyObject mine; // create a MyObject variable named 'mine'
mine.data = 4; // assign 4 to the data member of 'mine'</pre>

<h3>Methods</h3>
<p>A method is defined like a function, but with the name of
the object type before the method name, like this:</p>

<pre>int MyObject.add(int x) {
  data += x;
  return data;
}</pre>

<p>Within the context of a method, all the members of the object
can be accessed as if they are local variables, like <i>data</i> above. However,
if a local variable is defined with the same name as an object member, you must
use <code>this</code>, below, to access the member. Given the above definition of
<code>MyObject.add</code>:</p>
<pre>MyObject mine = { 4 }; // initialize mine.data to 4
mine.add(3); // adds 3 to mine.data</pre>

<p>Just as with pointers to structures, accessing members and methods of an object through a pointer
must be done with the <code>-&gt;</code> operator</p>

<pre>MyObject* pMine;
pMine = new MyObject; // allocate a new object
pMine-&gt;data = 9;
pMine-&gt;add(4); // use the -&gt; to call methods as well</pre>

<h3>this</h3>
<p>Within an object method, <code>this</code> is a special keyword that
represents the current object. (Unlike in C++, <code>this</code> is a reference to the object
rather than a pointer). this can be used to pass the current object to another
function as a parameter, but is not required to access the members or methods of
the object.</p>

<pre>void doSomething(MyObject myo) { }

int MyObject.add(int x) {
  doSomething(this); // call the doSomething method, using the current object as a parameter
  return data;
}</pre>

<p><code>this</code> may also be used to access an object member that is hidden by a local
variable:</p>

<pre>int MyObject.add(int x) {
  int data; // local variable
  data = 5; // changes the value of the local variable, not the member
  this.data += x; // adds x to the member 'data'
  return this.data;
}</pre>

<h3>_init, _destroy, _copy</h3>
<p>There are three special methods that can be defined for an
object. Calls to these methods are generated automatically by the compiler, and
they cannot be called directly by the developer. These methods are optional, and
default implementations will be generated by the compiler if they are required
and the developer has not defined them.</p>

<p><b>void _init()</b></p>
<p>This method is called automatically when an object is being
created. When an object is created with the <code>new</code> keyword, this method is called
upon successful creation. If the object is a global variable, this method is
called before the application starts. If the object is a local variable, this
method is called upon entry into the containing function. If the object contains
other objects with _init defined, those objects are initialized before the
containing object.</p>

<p><b>void _destroy()</b></p>
<p>This method is called automatically when an object is being
deleted. When an object is deleted with the <code>delete</code> keyword, this method is
called upon successful deletion. If the object is a global variable, this method
is called after the application exits. If the object is a local variable, this
method is called just before the containing function returns. If the object
contains other objects with _destroy defined, those objects are destroyed after
the containing object.</p>

<p><b>void _copy(<i>object-type</i> source)</b></p>
<p>This method is called automatically when an object is being
copied - when an object is assigned to another object or when an object is
returned from a function. If this method is not defined, the compiler may
generate one (if it needs to do so). If the method is defined, the developer is
required to manually copy all the important members (inherited members and 
member objects with _copy() methods are automatically copied by the compiler 
before the method body begins). When defined, an assignment
such as a = b would generate a call which would look like a._copy(b).</p>

<p>Here is an example to demonstrate how these methods work:</p>

<pre>object Person {
  _init();
  _destroy();
  _copy(Person);
  string name;
  int age;
};

void test() {
  Person a, b; // allocates stack space, calls a._init() and b._init()
  Person* p;
  
  a.name = &quot;Jon&quot;;
  b = a; // generates call to b._copy(a)
  p = new Person; // allocates heap space, calls p-&gt;_init()
  *p = a; // generates call to p-&gt;_copy(a)
  delete p; // calls p-&gt;_destroy(), frees heap space
} // calls b._destroy() and a._destroy()</pre>
<h3>Objects vs. Structs</h3>
<p>A struct and an object are very similar - they both support methods and 
members. However, an object cannot inherit from a struct and only objects may 
inherit from other objects and interfaces.</p>
