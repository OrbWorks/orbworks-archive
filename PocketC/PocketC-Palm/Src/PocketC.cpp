#include <SysEvtMgr.h>
#include <FeatureMgr.h>	// Needed to detect ROM versions
#include <DLServer.h>   // Needed to get user name
#include "PocketC_res.h"
#include "PocketC.h"
#include "PalmChars.h"

#ifdef EVIL_CHECK
ULong evilCode = 0x114f0f08; // xor'd to get PwKg
volatile ULong modEvil = 'A8Do';
ULong hasEvil;
#endif

void* operator new(unsigned long size) {
    return MemPtrNew(size);
}

void operator delete(void* p) {
    MemPtrFree(p);
}

void* operator new[](unsigned long size) {
    return MemPtrNew(size);
}

void operator delete[](void* p) {
    MemPtrFree(p);
}

void Alert(char* msg) {
    FrmCustomAlert(MsgBoxAlert, msg, "", "");
}

ResizeData resizeData[] = {
#ifndef POCKETC_RUNTIME
    { MainForm, RESIZE_STRETCH, 4 },
#else
    { MainForm, RESIZE_STRETCH, 3 },
#endif
    { MainProgsList, RESIZE_STRETCH },
    { MainExecuteButton, RESIZE_Y_ATTACH_BOTTOM },
    { MainOutputButton, RESIZE_Y_ATTACH_BOTTOM },
#ifndef POCKETC_RUNTIME
    { MainCompileButton, RESIZE_Y_ATTACH_BOTTOM },
#endif
    { OutputForm, RESIZE_STRETCH, 4 },
    { OutputOutputField, RESIZE_STRETCH },
    { OutputClearButton, RESIZE_Y_ATTACH_BOTTOM },
    { OutputDoneButton, RESIZE_Y_ATTACH_BOTTOM },
    { OutputScrollScrollBar, RESIZE_Y_STRETCH | RESIZE_X_ATTACH_RIGHT },
    { GraphForm, RESIZE_STRETCH, 0 },
#ifndef POCKETC_RUNTIME
    { CompileForm, RESIZE_STRETCH, 4 },
    { CompileMemoList, RESIZE_STRETCH },
    { CompileCompileButton, RESIZE_Y_ATTACH_BOTTOM },
    { CompileCancelButton, RESIZE_Y_ATTACH_BOTTOM },
    { CompileStatusLabel, RESIZE_Y_ATTACH_BOTTOM },
#endif
};
int cResizeData = sizeof(resizeData) / sizeof(resizeData[0]);

struct {
    short id, line;
    char* src;
    char* isrc;
    Handle src_h;
    char name[32];
    
    // DOC support
    bool bDoc;
} incStack[4];

char msg[384];
void c_error(char* m, short line) {
    short res;
    
    // Sometimes there are errors while the func handle is locked
    if (MemHandleLockCount(func_h)) MemHandleUnlock(func_h);
    if (global_h) { h_free(global_h); global_h=0; }
    if (reloc_h) { h_free(reloc_h); reloc_h=0; }
    if (line>0) {
        StrPrintF(msg, "File: %s\nLine: %d\n%s", incStack[incLevel].name, line, m);
        res = FrmCustomAlert(CompilerErrorAlert, msg, "", "");
    } else
        res = FrmCustomAlert(CompilerErrorAlert, m, "", "");
        
    // cleanup parser, delete currupt db, exit
    if (res) ErrThrow(4); // Jump to source
    else ErrThrow(1);
}

short appVer = 0;
long fullAddr(long addr);
#ifdef POCKETC_FAT
char* funcFromLoc(long loc);
extern bool bForceExit;
void vm_error(char* m, unsigned short pc) {
    long loc = fullAddr(pc);
    char* name = funcFromLoc(loc);
    if (name)
        StrPrintF(msg, "Addr: %li\nFunc: %s\n%s", loc, name, m);
    else
        StrPrintF(msg, "Addr: %li\n%s", loc, m);
    FrmCustomAlert(VMErrorAlert, msg, "", "");
    // cleanup VM
    bForceExit = true;
    ErrThrow(2);
}
#endif

#ifdef POCKETC_RUNTIME
void oom() {
    ErrFatalDisplayIf(true, "Out of memory");
}
#endif		

/***********************************************************************
 *   Entry Points
 ***********************************************************************/


/***********************************************************************
 *   Internal Structures
 ***********************************************************************/
typedef enum { FTMain, FTOutput } FormName;
typedef	struct {
    Word outputScrollPos;
    FormName currentForm;
    Int	selProg;
    ULong regCode;
    bool registered;
    char lastApp[32];
    char memoApp[32];
    char docApp[32];
} PcPreferenceType;

ULong firstUsed	= 0;
PcPreferenceType prefs = { 0, FTMain, 0, 0,	false };

typedef	struct {
    UInt renamedCategories;	// bitfield	of categories with a different name
    char categoryLabels[dmRecNumCategories][dmCategoryLength];
    Byte categoryUniqIDs[dmRecNumCategories];
    Byte lastUniqID; //	Uniq IDs generated by the device are between
    // 0 - 127.	 Those from	the	PC are 128 - 255.
    Byte reserved1;	// from	the	compiler word aligning things
    Word reserved2;
    CountryType	country; //	Country	the	database (labels) is formatted for
} PcAppInfoType;

typedef	PcAppInfoType* PcAppInfoPtr;


/***********************************************************************
 *	 Global	variables
 ***********************************************************************/
Boolean	HideSecretRecords;
static DmOpenRef PcDB;
static FontID AppFontID	= stdFont;
static Boolean SaveBackup =	false;
bool bForceExit	= false;

EventQueue eventQueue;

/***********************************************************************
 *	 Internal Constants
 ***********************************************************************/
#define	appFileCreator				'PktC'
#define	appPrefID					0x00
#define	appPrefVersionNum			0x01
#define	appDBName					"PcDB"
#define	appDBType					'PCdb'
#define	appUserDBType				'user'
#define	appVMDBType					'PCvm'
// Version Checking	define
#define	version20					0x02000000


/***********************************************************************
 *	 Internal Functions
 ***********************************************************************/
#ifdef POCKETC_RUNTIME
char hval(char c) {
    if (isdigit(c))	return c-'0';
    if (c >='A'	&& c <=	'F') c+=32;
    if (c >= 'a' &&	c <= 'f') return c - 'a' + 10;
    return 0;
}
#endif

/***********************************************************************
 *
 *	 GetObjectPtr
 *
 ***********************************************************************/
VoidPtr	GetObjectPtr(Word objectID) {
    FormPtr	frmP;

    frmP = FrmGetActiveForm();
    return (FrmGetObjectPtr(frmP, FrmGetObjectIndex(frmP,	objectID)));
}

/***********************************************************************
 *
 * FUNCTION: PcAppInfoInit
 *
 * DESCRIPTION:	Create an app info chunk if	missing.  Set
 *		the	strings	to a default.
 *
 * PARAMETERS: db -	open database pointer
 *
 * RETURNS:	0 if successful, errorcode if not
 *
 ***********************************************************************/
Err	PcAppInfoInit(DmOpenRef	dbP) {
    UInt cardNo;
    LocalID	dbID;
    LocalID	appInfoID;
    Handle tempH;
    PcAppInfoPtr appInfoP = NULL;
    PcAppInfoPtr defaultApplicationInfoP;
    Int	loop;

    // If there	isn't an ApplicationInfo make space	for	one
    if (appInfoP ==	NULL) {
        if (DmOpenDatabaseInfo(dbP,	&dbID, NULL, NULL, &cardNo,	NULL))
            return dmErrInvalidParam;

        if (DmDatabaseInfo(cardNo, dbID, NULL, NULL, NULL, NULL, NULL, NULL, NULL, &appInfoID, NULL, NULL, NULL))
            return dmErrInvalidParam;

        tempH =	(Handle)DmNewHandle(dbP, sizeof(PcAppInfoType));
        if (!tempH)	
            return dmErrMemError;

        appInfoID =	MemHandleToLocalID(	tempH);
        DmSetDatabaseInfo(cardNo, dbID,	NULL, NULL,	NULL, NULL,	NULL, NULL,	NULL, &appInfoID, NULL,	NULL, NULL);
        appInfoP = (PcAppInfoPtr)MemHandleLock(tempH);
    }

    // Allocate	& Clear	the	app	info
    defaultApplicationInfoP	= (PcAppInfoPtr)MemPtrNew(sizeof(PcAppInfoType));
    if (defaultApplicationInfoP	== NULL) {
        ErrDisplay("Unable to init PcDB");
        return 1;
    }

    MemSet(	defaultApplicationInfoP, sizeof(PcAppInfoType),	0);
    // Init	the	categories
    for	(loop =	0; loop	< dmRecNumCategories; loop++) {
        defaultApplicationInfoP->categoryUniqIDs[loop] = loop;
    }

    defaultApplicationInfoP->lastUniqID	= dmRecNumCategories - 1;
    // copy	in the defaults	and	free the default app info
    DmWrite(appInfoP, 0, defaultApplicationInfoP,  sizeof(PcAppInfoType));
    MemPtrFree(defaultApplicationInfoP);
    // Unlock
    MemPtrUnlock(appInfoP);
    return 0;
}

static Err RomVersionCompatible(DWord requiredVersion, Word	launchFlags) {
    DWord romVersion;

    // See if we have at least the minimum required	version	of the ROM or later.
    FtrGet(sysFtrCreator, sysFtrNumROMVersion, &romVersion);
    if (romVersion < requiredVersion) {
        if ((launchFlags & (sysAppLaunchFlagNewGlobals | sysAppLaunchFlagUIApp))) {
            // Pilot 1.0 will continuously relaunch	this app unless	we switch to 
            // another safe	one.
            Alert("This	version	of PocketC requires	PalmOS 2.0");
            if (romVersion < version20)	{
                AppLaunchWithCommand(sysFileCDefaultApp, sysAppLaunchCmdNormalLaunch, NULL);
            }
        }
        return sysErrRomIncompatible;
    }
    return 0;
}

/***********************************************************************
 *
 *  GraphicForm
 *
 ***********************************************************************/

static Boolean GraphFormHandleEvent(EventPtr eventP) {
    Boolean handled = false;
    FormPtr frmP;
    
    if (enableResize) {
        if (HandleResizeEvent(FrmGetActiveFormID(), eventP))
            return true;
    }

    switch (eventP->eType) {
        case menuEvent: {
            Word id = eventP->data.menu.itemID;
            if (id == GAppletStop) {
                killVM = true;
                handled = true;
                break;
            }
        }

        case frmOpenEvent:
            frmP = FrmGetActiveForm();
            FrmDrawForm(frmP);
            handled = true;
            break;
        
        case frmUpdateEvent:
            eventQueue.AddEvent(EventQueue::eqUpdate, eventP->data.frmUpdate.updateCode, 0);
            break;
    }

    return handled;
}


/***********************************************************************
 *
 *  OutputForm
 *
 ***********************************************************************/

void OutputFormUpdateScrollBar() {
    Word scrollPos, textHeight, fieldHeight;
    Short maxValue;
    FieldPtr fld;
    ScrollBarPtr bar;

    fld = (FieldPtr)GetObjectPtr(OutputOutputField);
    bar = (ScrollBarPtr)GetObjectPtr(OutputScrollScrollBar);
    
    FldGetScrollValues (fld, &scrollPos, &textHeight,  &fieldHeight);

    if (textHeight > fieldHeight) maxValue = textHeight - fieldHeight;
    else if (scrollPos) maxValue = scrollPos;
    else maxValue = 0;

    SclSetScrollBar (bar, scrollPos, 0, maxValue, fieldHeight-1);
}

static void OutputFormScroll (Short linesToScroll) {
    Word blankLines;
    Short min, max, value, pageSize;
    FieldPtr fld;
    ScrollBarPtr bar;
    
    fld = (FieldPtr)GetObjectPtr(OutputOutputField);

    if (linesToScroll < 0) {
        blankLines = FldGetNumberOfBlankLines (fld);
        FldScrollField (fld, -linesToScroll, winUp);
        
        // If there were blank lines visible at the end of the field
        // then we need to update the scroll bar.
        if (blankLines) {
            // Update the scroll bar.
            bar = (ScrollBarPtr)GetObjectPtr(OutputScrollScrollBar);
            SclGetScrollBar (bar, &value, &min, &max, &pageSize);
            if (blankLines > -linesToScroll) max += linesToScroll;
            else max -= blankLines;
            SclSetScrollBar (bar, value, min, max, pageSize);
        }
    } else if (linesToScroll > 0) FldScrollField (fld, linesToScroll, winDown);
}

static void OutputFormScrollPage (WinDirectionType direction) {
    Short value, min, max, pageSize;
    Word linesToScroll;
    FieldPtr fld;
    ScrollBarPtr bar;

    fld = (FieldPtr)GetObjectPtr(OutputOutputField);
    
    if (FldScrollable(fld, direction)) {
        linesToScroll = FldGetVisibleLines (fld) - 1;
        FldScrollField(fld, linesToScroll, direction);

        // Update the scroll bar.
        bar = (ScrollBarPtr)GetObjectPtr(OutputScrollScrollBar);
        SclGetScrollBar(bar, &value, &min, &max, &pageSize);

        if (direction == winUp) value -= linesToScroll;
        else value += linesToScroll;
        
        SclSetScrollBar(bar, value, min, max, pageSize);
    }
}

static void OutputFormInit(FormPtr) {
    FieldPtr fp = (FieldPtr)GetObjectPtr(OutputOutputField);
    FldSetTextHandle(fp, output);
    FldSetScrollPosition(fp, prefs.outputScrollPos);
    OutputFormUpdateScrollBar();
}

static Boolean OutputFormDoCommand(Word command) {
    FieldPtr pField;
    Boolean handled = true;

    switch (command) {
        case OAppletStop:
            killVM = true;
            break;
            
        case EditSelectAll:
            pField = (FieldPtr)GetObjectPtr(OutputOutputField);
            FldSetSelection(pField, 0, FldGetTextLength(pField));
            break;
            
        case EditCopy:
            pField = (FieldPtr)GetObjectPtr(OutputOutputField);
            FldCopy(pField);
            break;
            
        default:
            handled = false;
            break;
    }
    return handled;
}

static Boolean OutputFormHandleEvent(EventPtr eventP) {
    Boolean	handled	= false;
    FormPtr	frmP;

    if (HandleResizeEvent(FrmGetActiveFormID(), eventP))
        return true;

    switch (eventP->eType) {
        case ctlSelectEvent:
            switch (eventP->data.ctlSelect.controlID) {
                case OutputDoneButton: {
                    killVM = true;
                    FrmGotoForm(MainForm);
                    handled	= true;
                    break;
                }

                case OutputClearButton:	{
                    FieldPtr fp = (FieldPtr)GetObjectPtr(OutputOutputField);
                    FldDelete(fp, 0, -1);
                    FldDrawField(fp);
                    handled	= true;
                    break;
                }
            }
            break;

        case menuEvent:
            return OutputFormDoCommand(eventP->data.menu.itemID);

        case keyDownEvent:
            if (eventP->data.keyDown.chr==pageUpChr) {
                OutputFormScrollPage(winUp);
                handled	= true;
            } else if (eventP->data.keyDown.chr==pageDownChr) {
                OutputFormScrollPage(winDown);
                handled	= true;
            }
            break;

        case fldChangedEvent:
            OutputFormUpdateScrollBar();
            handled	= true;
            break;

        case frmOpenEvent:
            frmP = FrmGetActiveForm();
            OutputFormInit(frmP);
            FrmDrawForm(frmP);
            handled	= true;
            break;

        case sclRepeatEvent:
            OutputFormScroll(eventP->data.sclRepeat.newValue - eventP->data.sclRepeat.value);
            // not handled, so that the button continues repeating;
            break;

        case frmCloseEvent:	{
            FieldPtr fp	= (FieldPtr)GetObjectPtr(OutputOutputField);
            prefs.outputScrollPos =	FldGetScrollPosition(fp);
            FldSetTextHandle(fp, 0);
            //handled =	true;
            break;
        }
    }

    return handled;
}


/***********************************************************************
 *
 *	Applet Deletion
 *
 ***********************************************************************/
void DeleteDB()	{
    char* name;
    short sel;
    
    ListPtr	lp = (ListPtr)GetObjectPtr(MainProgsList);
    sel	= LstGetSelection(lp);
    if (sel	< 0) {
        Alert("No applet selected");
        return;
    }
    name = LstGetSelectionText(lp, sel);
    LocalID	lid	= DmFindDatabase(0,	name);
    if (!lid) {
        StrPrintF(msg, "Error finding applet '%s'",	name);
        Alert(msg);
        return;
    }
    if (FrmCustomAlert(DeleteAlert,	name, NULL,	NULL)) return;
    if (DmDeleteDatabase(0,	lid)) {
        StrPrintF(msg, "Error deleting applet '%s'", name);
        Alert(msg);
    }
}


/***********************************************************************
 *
 *	Registration Code
 *
 ***********************************************************************/

short RegCheck() {
#ifdef POCKETC_RETAIL
    return 0;
#else	
    if (prefs.registered) return 0;
    if (TimGetSeconds()	- firstUsed	> 5184000UL) return	2;
    if (TimGetSeconds()	- firstUsed	> 3888000UL) return	1;
    return 0;
#endif
}

ULong genCode(char*	name) {
    ULong code = 123456789;
    while (*name) {
        code *=	*name++;
        code %=	1000000000;
    }
    return code;
}	

/***********************************************************************
 *
 *	Applet Execution
 *
 ***********************************************************************/

void setPC(long	addr);
unsigned char getCode(long addr);

void CallFunc(long loc)	{
    Value op1;
    op1.type = vtAddr;
    op1.iVal = 0;
    push(op1);
    if (appVer >= 0x0500) {
        op1.type = vtSavedFB;
        op1.iVal = fb;
        push(op1);
    }
    long old_pc	= fullAddr(pc);
    unsigned short old_fb =	fb;
    setPC(loc);
    if (appVer >= 0x0500) {
        fb = pc;
    }
    exec();
    setPC(old_pc);
    fb = old_fb;
    bForceExit = false;	
}

void OldCallFunc(unsigned short	loc) {
    CallFunc(loc);
}

bool CallBI(char* name)	{
    short i;
    for	(i=0;i<nBIFuncs;i++)
        if (!strcmp(funcTable[i].name, name)) goto found;
    return false;
found:
    retVal.iVal	= 0;
    retVal.type	= vtInt;
    ((void(*)(short))funcTable[i].loc)(i);
    ValueToOld(retVal);
    return true;
}

bool OldUIYield(bool blocking) { return	UIYield(blocking); } //	for	native libs
UInt32 vmCtrl(UInt32 id, UInt32	val) {
    switch (id)	{
        case VMCTRL_ENABLE_EVENTS:
            nativeEnableEvents = !!val;
            return nativeEnableEvents;
        default:
            return 0;
    }
}

//#define LIB_DEBUG
#ifdef LIB_DEBUG
#define	wassert(x) { if	(!(x)) Alert("ASSERT failed: " #x);	}
#else
#define	wassert(x) ;
#endif


LocalID	MyFindDatabase(char* name, UInt16& card) {
    UInt16 nCards =	MemNumCards();
    for	(card=0;card<nCards;card++)	{
        LocalID	lid	= DmFindDatabase(card, name);
        if (lid)
            return lid;
    }
    return NULL;
}

bool LoadAddin(char* name, UInt16 resid, AddIn& addIn) {
    MemHandle hAddIn = NULL;
    NATIVE_ENTRY_FUNC func = NULL;
    LocalID lid = NULL;
    DmOpenRef dbRef = NULL;
    
    if (*name != '\0') {
        // load addin database by name
        UInt16 card = 0;
        lid = MyFindDatabase(name, byref card);
        if (!lid) return false;
        dbRef = DmOpenDatabase(card, lid, dmModeReadOnly);
        if (!dbRef) return false;
        hAddIn = DmGetResource('pcNA', 0);
        if (!hAddIn) DmCloseDatabase(dbRef);
    } else {
        // load addin resource by id
        hAddIn = DmGetResource('pcNA', resid);
    }
    
    if (hAddIn) {
        addIn.libRef = 0xffff;
        addIn.func = (NATIVE_ENTRY_FUNC)MemHandleLock(hAddIn);
        addIn.hAddIn = hAddIn;
        addIn.dbRef = dbRef;
        addIn.data = (*addIn.func)(&pci, NULL, NATIVE_STARTUP);
        return true;
    } else {
        return false;
    }
}

PocketCLibraryApiExt pcae;

UInt16 LoadLib(char* name) {
    UInt16 card	= 0;
    LocalID	lid	= MyFindDatabase(name, byref card);
    if (!lid) {
        wassert(!"Unable to	find database");
        return 0;
    }
    
    ULong creator, type;
    if (DmDatabaseInfo(card, lid, 0, 0,	0, 0, 0, 0,	0, 0, 0, &type,	&creator)) {
        wassert(!"Unable to	get	creator	id");
        return 0;
    }
    UInt ref;
    Err	err;
    if ((err = SysLibLoad(type,	creator, &ref))	!= 0) {
#ifdef LIB_DEBUG
        StrPrintF(msg, "SysLibLoad returned	%d", err);
        Alert(msg);
#endif
        //wassert(!"SysLibLoad failed");
        return 0;
    }
    
    PocketCLibGlobalsPtr gP	= PocketCLibOpen(ref, NULL);
    if (!gP) {
        wassert(!"Library's	open routine failed");
        SysLibRemove(ref);
        return 0;
    }
    gP->pop	= oldpop;
    gP->push = oldpush;
    gP->cleanup	= oldCleanup;
    gP->typeCast = oldTypeCast;
    gP->typeMatch =	oldTypeMatch;
    gP->UIYield	= OldUIYield;
#ifdef POCKETC_RUNTIME
    gP->addLibFunc = 0;
#else
    gP->addLibFunc = addLibFunc;
#endif
    gP->callFunc_deprecated = OldCallFunc;
    gP->callFunc32 = CallFunc;
    gP->callBI = CallBI;
    gP->deref =	deref;
    gP->lockString_deprecated = LockStringOld;
    gP->unlockString_deprecated = UnlockStringOld;
    gP->retVal = &retVal;
    gP->vmCtrl = vmCtrl;
    
    pcae.lockString = LockString;
    pcae.unlockString = UnlockString;
    pcae.acquireString = AcquireString;
    pcae.releaseString = ReleaseString;
    pcae.unlockReleaseString = UnlockReleaseString;
    pcae.newString = NewString;
    pcae.newStringFromConst = NewStringFromConst;
    pcae.newConstString = NewConstString;
    
    gP->apiExt = &pcae;
    
    MemPtrUnlock(gP);

    return ref;
}

struct SizeData	{
    unsigned short size;
    char data[];
};

bool killEvents, killVM, openOutput, bLaunchApp	= false;
bool nativeEnableEvents	= true, enableResize = false;


short getWord();

void Execute(char* name) {
    openOutput = false;
    bool ver35plus = false;
    nativeEnableEvents = true;
    
    short i, j,	k;
#ifndef	POCKETC_FAT
    short sel;
    if (!name) {
        ListPtr	lp = (ListPtr)GetObjectPtr(MainProgsList);
        sel	= LstGetSelection(lp);
        if (sel	< 0) {
            Alert("No applet selected");
            return;
        }
        name = LstGetSelectionText(lp, sel);
    }
    LocalID	lid	= DmFindDatabase(0,	name);
    if (!lid) {
        StrPrintF(msg, "Error loading applet '%s'",	name);
        Alert(msg);
        goto mainForm;
    }
    UInt attribs;
    ULong type;
    
    DmDatabaseInfo(0, lid, 0, &attribs, 0,0,0,0,0,0,0, &type, 0);
    if (type != 'PCvm' && type != 'appl') {
        Alert("Invalid applet database");
        goto mainForm;
    }

    bool bRes = (attribs & dmHdrAttrResDB);
    DmOpenRef codeDB = DmOpenDatabase(0, lid, dmModeReadOnly);
    if (!codeDB) {
        Alert("Error opening applet");
        goto mainForm;
    }
#else
    bool bRes = true;
#endif
    SizeData* sd;
    
    for (i=0;i<MAX_CODE_SEGS;i++)
        codesegs[i] = NULL;
        
    if (bRes) code_h = DmGet1Resource('PCpc', 1001);
    else code_h = DmGetRecord(codeDB, 0);
    if (!code_h) {
        Alert("Invalid applet database");
        DmCloseDatabase(codeDB);
        goto mainForm;
    }
    sd = (SizeData*)MemHandleLock(code_h);
    codePtr = sd->size;
    code = codesegs[0] = (unsigned char*)sd->data;
    for (i=1;i<MAX_CODE_SEGS;i++) {
        Handle h = NULL;
        if (bRes) {
            h = DmGet1Resource('PCpc', 1004 + i);
        } else {
            if (i + 3 < DmNumRecords(codeDB))
                h = DmGetRecord(codeDB, i+3);
        }
        if (!h) break;
        codesegs[i] = (unsigned char*)MemHandleLock(h);
    }
    
    if (bRes) floats_h = DmGet1Resource('PCpc', 1002);
    else floats_h = DmGetRecord(codeDB, 1);
    sd = (SizeData*)MemHandleLock(floats_h);
    nFloats = sd->size;
    cFloats = (float*)sd->data;
    
    if (bRes) strings_h = (Handle)DmGet1Resource('PCpc', 1003);
    else strings_h = (Handle)DmGetRecord(codeDB, 2);
    sd = (SizeData*)MemHandleLock(strings_h);
    nStrChars = sd->size;
    cStrings = sd->data;
    
    VoidHand glob_h;
    if (bRes) glob_h = DmGet1Resource('PCpc', 1004);
    else glob_h = DmGetRecord(codeDB, 3);
    short* gt = (short*)MemHandleLock(glob_h);
    nGlobals = gt[0];
    globalOff = gt[1];
    globals = 0;
    
    pc = 0;
    fp = 0;
    st = 0;
    fb = 0;
    
    if (code[3] == vmHalt) {
        ver35plus = true;
        appVer = code[5] * 256 + code[6];
        if (appVer > CURRENT_VERSION) {
            Alert("This app was created with a newer version of PocketC, "
            "and may not run properly. To get the current version, "
            "go to www.orbworks.com");
        }
    }
        
    libNum = 0;
    if (code[0]==vmHalt) {
        // load libraries
        long addr;
        if (appVer >= 0x0500) {
            addr = ((ULong)code[11] << 24) + ((ULong)code[12] << 16) + ((ULong)code[1] << 8) + (ULong)code[2];
        } else {
            addr = ((ULong)code[1] << 8) + (ULong)code[2];
        }
            
        if (addr==0) goto noLibs;
        libNum = getCode(addr++);
        MemSet(addIns, sizeof(AddIn)*libNum, 0);
        InitPCI();
        for (i=0;i<libNum;i++) {
            unsigned short resid = 0xffff;
            if (appVer >= 0x650) {
                resid = getCode(addr + libNum*2) * 256 + getCode(addr + libNum*2 + 1);
            }
            name = &cStrings[getCode(addr) * 256 + getCode(addr+1)];
            if (resid == 0xffff) {
                // native library
                addIns[i].libRef = LoadLib(name);
                if (!addIns[i].libRef) {
                    StrPrintF(msg, "Unable to load library '%s'", name);
                    Alert(msg);
                    goto libError;
                }
            } else if (resid != 0xfffe) {
                // native add-in
                if (!LoadAddin(name, resid, byref addIns[i])) {
                    StrPrintF(msg, "Unable to load add-in '%s':%d", name, resid);
                    Alert(msg);
                    goto libError;
                }
            }
            addr += 2;
        }
noLibs:
        pc = 3;
    }
    
    if (ver35plus) {
        pc = code[4] + 5;
        // setup the debug data location
        if (appVer >= 0x0500) {
            dbgLoc = ((ULong)code[7] << 24) + ((ULong)code[8] << 16) + ((ULong)code[9] << 8) + (ULong)code[10];
        } else if (appVer >= 0x0410) {
            dbgLoc = code[7] * 256 + code[8];
        }
        
        if (appVer >= 0x0500) {
            codePtr = ((ULong)code[13] << 24) + ((ULong)code[14] << 16) + ((ULong)code[15] << 8) + (ULong)code[16];
            fb = pc;
        }
    }
        
    // Since malloc should return 0 only for an error, we need to allocate the
    // 0th spot ahead of time, either with a global or a fake global
    if (globalOff == 0) globalOff = 1; 
    global_h = h_malloc(globalOff * sizeof(Value));
    if (!global_h) goto MemoryError;
    globals = (Value*)MemHandleLock(global_h);
    MemSet(globals, globalOff*sizeof(Value), 0);

    // Initialize global block
    j=0;
    for (i=0;i<nGlobals;i++) {
        for (k=0;k<gt[i*2+3];k++) {
            globals[j].type = (VarType)gt[i*2+2];
            switch (globals[j].type) {
                case vtInt:
                case vtChar:
                    globals[j].iVal=0;
                    break;
                case vtString:
                    NewConstString(&globals[j], "");
                    break;
                case vtFloat:
                    globals[j].fVal = 0.0;
                    break;
            }
            j++;
        }
    }	
    
    if (ver35plus) {
        j = nGlobals*2+2;
        nGlobalInits = gt[j];
        for (i=0; i<nGlobalInits; i++) {
            if (gt[j+i*4+1] > globalOff)
                Alert("Invalid address!!");
            if (globals[gt[j+i*4+1]].type != (VarType)gt[j+i*4+2])
                Alert("Incorrect type!!");
                
            short off = gt[j+i*4+1];
            VarType type = (VarType) gt[j+i*4+2];
            switch (type) {
                case vtInt:
                    globals[off].iVal = ((unsigned long)gt[j+i*4+3] << 16);
                    globals[off].iVal |= (unsigned short)gt[j+i*4+4];
                    break;
                case vtFloat:
                    globals[off].fVal = cFloats[gt[j+i*4+4]];
                    break;
                case vtChar:
                    globals[off].cVal = gt[j+i*4+4];
                    break;
                case vtString:
                    ReleaseString(&globals[off]); // release hNullString
                    NewConstString(&globals[off], &cStrings[gt[j+i*4+4]]);
                    break;
            }
        }
    }

    stack_h = h_malloc(sizeof(Value)*40);
    if (!stack_h) goto MemoryError;
    stack = (Value*)MemHandleLock(stack_h);
    stackSize = 40;

    initLib();
    killEvents = killVM = enableResize = false;
    if (!bLaunchApp) {
        openOutput = true;
        FrmGotoForm(OutputForm);
    }
    bLaunchApp = false;
    ErrTry {
        UIYield(false); // Process the messages to change the form
        eventQueue.Clear(); // clear the penUpEvent
        exec();
    }
    ErrCatch(err) {
        ;
    } ErrEndCatch
    
    closeLib();

libError:
    for (i=0; i<libNum; i++) {
        if (addIns[i].libRef == 0xffff) {
            // it is a native add-in
            (*addIns[i].func)(&pci, addIns[i].data, NATIVE_SHUTDOWN);
            if (addIns[i].hAddIn) {
                MemHandleUnlock(addIns[i].hAddIn);
                DmReleaseResource(addIns[i].hAddIn);
            }
            if (addIns[i].dbRef) {
                DmCloseDatabase(addIns[i].dbRef);
            }
        } else if (addIns[i].libRef) {
            // it is a native library
            PocketCLibClose(addIns[i].libRef, 0);
            SysLibRemove(addIns[i].libRef);
        }
    }
    
memCleanup:
    if (globals) {
        for (i=0; i<globalOff;i++)
            if (globals[i].type==vtString && globals[i].sVal) ReleaseString(&globals[i]);
        MemHandleUnlock(global_h);
        h_free(global_h);
    }

    // Cleanup stack
    for (i=0; i<st; i++)
        if (stack[i].type==vtString) ReleaseString(&stack[i]);
    if (stack_h) h_free(stack_h);
    stack_h = NULL;
    MemHandleUnlock(glob_h);
    MemHandleUnlock(strings_h);
    MemHandleUnlock(floats_h);
    MemHandleUnlock(code_h);
    if (bRes) {
        DmReleaseResource(glob_h);
        DmReleaseResource(strings_h);
        DmReleaseResource(floats_h);
        DmReleaseResource(code_h);
    } else {
        DmReleaseRecord(codeDB, 3, false);
        DmReleaseRecord(codeDB, 2, false);
        DmReleaseRecord(codeDB, 1, false);
        DmReleaseRecord(codeDB, 0, false);
    }
    for (i=1;i<MAX_CODE_SEGS;i++) {
        if (codesegs[i] == NULL) break;
        Handle h = MemPtrRecoverHandle(codesegs[i]);
        MemHandleUnlock(h);
        if (bRes) DmReleaseResource(h);
        else DmReleaseRecord(codeDB, i+3, false);
    }
#ifndef POCKETC_FAT
    DmCloseDatabase(codeDB);
#endif

mainForm:
    FrmGotoForm(MainForm);
    return;
    
MemoryError:
    Alert("Not enough memory to execute applet");
    goto memCleanup; // Mmmmmm, spaghetti

}
    

/***********************************************************************
 *
 *  MainForm
 *
 ***********************************************************************/
char lastApplet[32] = {0,};
DmOpenRef memoDB;
short FindMemo(char* name, bool prog);

#ifndef POCKETC_FAT
vector<char*>* pvNames;
#define vNames (*pvNames)

static void FillDBList(bool reDraw) {
    DmSearchStateType ss;
    LocalID lid;
    UInt card, attr;
    ListPtr lst;
    short i=0;

    vNames.clear();
    
#ifdef EVIL_CHECK
    // is the evil application installed
    if (DmGetNextDatabaseByTypeCreator(true, &ss, 'appl', evilCode ^ modEvil, false, &card, &lid))
        hasEvil = appFileCreator;
    else
        hasEvil = appVMDBType;
#endif

    if (DmGetNextDatabaseByTypeCreator(true, &ss,
        appVMDBType, appFileCreator, false, &card, &lid)) goto endListFill;

    i = 0;

    DmGetNextDatabaseByTypeCreator(true, &ss,	appVMDBType, appFileCreator,
        false, &card, &lid);
    do {
        char* name;
        name = new char[32];
        ErrFatalDisplayIf(!name, "Error initializing applet list");
        DmDatabaseInfo(card, lid, name, &attr,
            NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
        if (attr & (dmRecAttrSecret | dmRecAttrDelete)) {
            delete name;
            continue;
        }
            
        if (*lastApplet && 0==strcmp(lastApplet, name)) {
            prefs.selProg = i;
            *lastApplet = 0;
        }
        vNames.add(name);
        i++;
    } while (!DmGetNextDatabaseByTypeCreator(false, &ss,
        appVMDBType, appFileCreator, false, &card, &lid));

endListFill:
    lst = (ListPtr)GetObjectPtr(MainProgsList);
    LstSetListChoices(lst, vNames.lock(), i);
    if (reDraw) LstDrawList(lst);
    *lastApplet = 0;
}


static void Backup() {
    char* name;
    char* curr;
    short sel;
    
    ListPtr lp = (ListPtr)GetObjectPtr(MainProgsList);
    sel = LstGetSelection(lp);
    if (sel < 0) {
        Alert("No applet selected");
        return;
    }
    name = LstGetSelectionText(lp, sel);
    LocalID lid = DmFindDatabase(0, name);
    if (!lid) {
        StrPrintF(msg, "Error loading applet '%s'", name);
        Alert(msg);
        return;
    }
    UInt attr;
    DmDatabaseInfo(0, lid, 0, &attr, 0,0,0,0,0,0,0,0,0);
    if (attr & dmHdrAttrBackup) curr="Yes";
    else curr="No";
    if (FrmCustomAlert(BackupAlert, name, curr, NULL)) attr &= ~dmHdrAttrBackup;
    else attr |= dmHdrAttrBackup;
    DmSetDatabaseInfo(0, lid, 0, &attr, 0,0,0,0,0,0,0,0,0);
}

static void MainFormInit(FormPtr) {
    FillDBList(false);
}

static Boolean MainFormDoCommand(Word command) {
    Boolean handled = true;


    switch (command) {
        case OptionsAboutPocketC: {
            FormPtr pFrm = FrmInitForm(AboutForm);
            FrmDoDialog(pFrm);
            FrmDeleteForm(pFrm);
            break;
        }

#ifndef POCKETC_RETAIL
        case OptionsRegister: {
            if (prefs.registered) {
                char name[41]; *name='\0';
                DlkGetSyncInfo(NULL, NULL, NULL, name, NULL, NULL);
                if (!*name) strcpy(name, "copilot");
                FrmCustomAlert(AlreadyAlert, name, "", "");
            } else FrmPopupForm(RegisterForm);
            break;
        }
#endif

#ifndef POCKETC_RUNTIME
        case OptionsEditorOptions: {
            FrmPopupForm(EditorOptionsForm);
            break;
        }
#endif

        case AppletDelete: {
            DeleteDB();
            FillDBList(true);
            break;
        }

        case AppletBackup: {
            Backup();
            //FillDBList(true);
            break;
        }
        
        case AppletDatabases: {
            FrmPopupForm(DatabaseForm);
            break;
        }
        
        case AppletEditSource: {
            ListPtr lp = (ListPtr)GetObjectPtr(MainProgsList);
            short sel = LstGetSelection(lp);
            if (sel < 0) {
                Alert("No applet selected");
                break;
            }
            prefs.selProg = sel;
            memoDB = DmOpenDatabaseByTypeCreator('DATA', 'PMem', dmModeReadOnly);
            if (!memoDB)
                memoDB = DmOpenDatabaseByTypeCreator('DATA', sysFileCMemo, dmModeReadOnly);
            short id = FindMemo(LstGetSelectionText(lp, sel), true);
            DmCloseDatabase(memoDB);
            if (id < 0) {
                Alert("Source not found");
                break;
            }
            GoToParamsPtr gp = (GoToParamsPtr)MemPtrNew(sizeof(GoToParamsType));
            MemPtrSetOwner(gp, 0); // The guy at Palm Computing said to do this! :)
            gp->dbID = DmFindDatabase(0, "MemosDB-PMem");
            if (!gp->dbID)
                gp->dbID = DmFindDatabase(0, "MemoDB");
            gp->dbCardNo = 0;
            gp->recordNum = id;
            gp->matchPos = 0;
            gp->searchStrLen = 0;
            LocalID lid = DmFindDatabase(0, prefs.memoApp);
            if (!lid) lid = DmFindDatabase(0, "Memos-PMem");
            if (!lid) lid = DmFindDatabase(0, "Memo Pad");

            SysUIAppSwitch(0, lid, sysAppLaunchCmdGoTo, (Ptr)gp);
            break;
        }

        default:
            handled = false;
            break;

    }
    return handled;
}

static Boolean MainFormHandleEvent(EventPtr eventP) {
    Boolean	handled	= false;
    FormPtr	frmP;
    ListPtr	lst;
    short j;

    if (HandleResizeEvent(FrmGetActiveFormID(), eventP))
        return true;

    switch (eventP->eType) {
        case ctlSelectEvent:
            switch (eventP->data.ctlSelect.controlID) {
                case MainExecuteButton:	{
                    lst	= (ListPtr)GetObjectPtr(MainProgsList);
                    prefs.selProg =	LstGetSelection(lst);
                    handled	= true;
                    Execute(NULL);
                    break;
                }

#ifndef	POCKETC_RUNTIME
                case MainCompileButton:
                    vNames.clear();
                    FrmGotoForm(CompileForm); // This returns immediately
                    handled	= true;
                    break;
#endif
                case MainOutputButton: {
                    FrmGotoForm(OutputForm);
                    handled	= true;
                    break;
                }

            }
            break;

        case menuEvent:	{
            return MainFormDoCommand(eventP->data.menu.itemID);
            }

        case keyDownEvent:
            lst	= (ListPtr)GetObjectPtr(MainProgsList);
            if (eventP->data.keyDown.chr==pageUpChr) {
                LstScrollList(lst, winUp, 10);
                LstEraseList(lst);
                LstDrawList(lst);
                handled = true;
            } else if (eventP->data.keyDown.chr==pageDownChr) {
                LstScrollList(lst, winDown, 10);
                LstEraseList(lst);
                LstDrawList(lst);
                handled = true;
            }
            break;

        case frmOpenEvent:
            frmP = FrmGetActiveForm();
            MainFormInit(frmP);
            FrmDrawForm(frmP);
            lst	= (ListPtr)GetObjectPtr(MainProgsList);
            j=LstGetNumberOfItems(lst);
            if (j >	prefs.selProg) {
                if (prefs.selProg <	0) prefs.selProg = j-1;
                LstSetSelection(lst, prefs.selProg);
            }
            handled	= true;
            break;

        case frmCloseEvent:
            lst	= (ListPtr)GetObjectPtr(MainProgsList);
            prefs.selProg =	LstGetSelection(lst);
            vNames.clear();
            break;
    }

    return handled;
}

/***********************************************************************
 *
 *  AboutForm
 *
 ***********************************************************************/
static Boolean AboutFormHandleEvent(EventPtr eventP) {
    Boolean handled = false;
    FormPtr frmP;
    
    if (eventP->eType == frmOpenEvent) {
        frmP = FrmGetActiveForm();
        FrmDrawForm(frmP);
        handled = true;
    }
    
    return handled;
}
#endif

/***********************************************************************
 *
 *  RegisterForm
 *
 ***********************************************************************/
ULong preCalcRegCode;

#ifndef POCKETC_RUNTIME
static void RegisterFormInit(FormPtr frmP) {
    char name[43];
    *name = '\"';
    *(name+1) = '\0';
    DlkGetSyncInfo(NULL, NULL, NULL, name+1, NULL, NULL);
    
    if (!*(name+1)) strcpy(name, "copilot");
    else strcat(name, "\"");
    FrmCopyLabel(frmP, RegisterUserNameLabel, name);
}

static Boolean RegisterFormHandleEvent(EventPtr eventP) {
    Boolean handled = false;
    FormPtr frmP = FrmGetActiveForm();
    FieldPtr fp = (FieldPtr)GetObjectPtr(RegisterCodeField);
    char* code;

    char name[41];
    *name = '\0';
    DlkGetSyncInfo(NULL, NULL, NULL, name, NULL, NULL);
    if (!*name) strcpy(name, "copilot");

    switch (eventP->eType) {
        case ctlSelectEvent:
            switch (eventP->data.ctlSelect.controlID) {
                case RegisterOKButton:
                    code = FldGetTextPtr(fp);
                    if (code) prefs.regCode = atoi(code);
                    if (!code || preCalcRegCode != prefs.regCode) {
evilLabel:
                        FrmAlert(InvalidRegAlert);
                        if (code) prefs.registered = false;
                    } else {
#ifdef EVIL_CHECK
                        if (hasEvil == appVMDBType) goto evilLabel;
#endif
                        FrmAlert(ValidRegAlert);
                        prefs.registered = true;
                    }
                    handled = true;
                    FrmReturnToForm(MainForm);
                    break;

                case RegisterCancelButton:
                    handled = true;
                    FrmReturnToForm(MainForm);
                    break;

                default:
                    break;
            }
            break;

        case frmOpenEvent:
            frmP = FrmGetActiveForm();
            RegisterFormInit(frmP);
            FrmDrawForm (frmP);
            handled = true;
            break;

    }

    return handled;
}

#endif

/***********************************************************************
 *
 *  EditorOptionsForm
 *
 ***********************************************************************/

#ifndef POCKETC_RUNTIME
char** pEOList;
vector<char*>* pvAppNames;
#define vAppNames (*pvAppNames)

Int16 StringCompare(void* pa, void* pb, Int32) {
    return strcmp(*(char**)pa, *(char**)pb);
}

static void EOFormInit(FormPtr) {
    // set text of popup
    ControlPtr pCtrl = (ControlPtr)GetObjectPtr(EditorOptionsMemoTrigger);
    if (prefs.memoApp[0])
        CtlSetLabel(pCtrl, prefs.memoApp);
    else
        CtlSetLabel(pCtrl, "<none>");
    
    pCtrl = (ControlPtr)GetObjectPtr(EditorOptionsDocTrigger);
    if (prefs.docApp[0])
        CtlSetLabel(pCtrl, prefs.docApp);
    else
        CtlSetLabel(pCtrl, "<none>");

    // get list of all apps
    DmSearchStateType ss;
    Err err = 0;
    char* name;
    UInt16 card;
    LocalID lid;
    name = new char[32];
    strcpy(name, "<none>");
    vAppNames.add(name);
    err = DmGetNextDatabaseByTypeCreator(true, &ss, 'appl', 0, true, &card, &lid);
    while (err == 0 && lid) {
        name = new char[32];
        if (0 == DmDatabaseInfo(card, lid, name,0,0,0,0,0,0,0,0,0,0)) {
            vAppNames.add(name);
        } else {
            delete name;
        }
        err = DmGetNextDatabaseByTypeCreator(false, &ss, 'appl', 0, true, &card, &lid);
    }

    // sort the list (excluding first element)
    SysQSort(vAppNames.lock() + 1, vAppNames.size() - 1, sizeof(char*), StringCompare, 0);
    
    // set the list choices
    ListPtr pList = (ListPtr)GetObjectPtr(EditorOptionsMemoList);
    LstSetListChoices(pList, vAppNames.lock(), vAppNames.size());
    for (int i=0;i<vAppNames.size();i++) {
        if (!strcmp(vAppNames[i], prefs.memoApp)) {
            LstSetSelection(pList, i);
            LstMakeItemVisible(pList, i);
            break;
        }
    }
    pList = (ListPtr)GetObjectPtr(EditorOptionsDocList);
    LstSetListChoices(pList, vAppNames.lock(), vAppNames.size());
    for (int i=0;i<vAppNames.size();i++) {
        if (!strcmp(vAppNames[i], prefs.docApp)) {
            LstSetSelection(pList, i);
            LstMakeItemVisible(pList, i);
            break;
        }
    }
    
    // set the correct selection
}

static Boolean EOFormHandleEvent(EventPtr eventP) {
    Boolean handled = false;
    FormPtr frmP = FrmGetActiveForm();

    switch (eventP->eType) {
        case ctlSelectEvent:
            switch (eventP->data.ctlSelect.controlID) {
                case EditorOptionsDone: {
                    handled = true;
                    ControlPtr pCtrl = (ControlPtr)GetObjectPtr(EditorOptionsMemoTrigger);
                    strcpy(prefs.memoApp, CtlGetLabel(pCtrl));
                    pCtrl = (ControlPtr)GetObjectPtr(EditorOptionsDocTrigger);
                    strcpy(prefs.docApp, CtlGetLabel(pCtrl));
                    vAppNames.clear();
                    FrmReturnToForm(MainForm);
                    break;
                }
                    
                default:
                    break;
            }
            break;

        case frmOpenEvent:
            EOFormInit(frmP);
            FrmDrawForm (frmP);
            handled = true;
            break;

    }

    return handled;
}

#endif

/***********************************************************************
 *
 *  InputForm
 *
 ***********************************************************************/

bool inputDone;
Handle inputRet;
char* defValue;

static void InputFormInit(FormPtr) {
    FieldPtr fp = (FieldPtr)GetObjectPtr(InputEntryField);
    inputRet = (Handle)h_malloc(80);
    short len;
    
    if (!inputRet) vm_error("Out of memory",-1);
    if (defValue) {
        char* pir = (char*)MemHandleLock(inputRet);
        strcpy(pir, defValue);
        len = strlen(pir);
        MemHandleUnlock(inputRet);
    } else {
        ((char*)MemHandleLock(inputRet))[0] = '\0';
        MemHandleUnlock(inputRet);
    }
    FldSetTextHandle(fp, inputRet);
    if (defValue) {
        FldSetSelection(fp, 0, len);
    }
}

static Boolean InputFormHandleEvent(EventPtr eventP) {
    Boolean handled = false;
    FormPtr frmP;

    switch (eventP->eType) {
        case ctlSelectEvent:
            switch (eventP->data.ctlSelect.controlID) {
                case InputOKButton: {
                    inputDone = true;
                    FieldPtr fp = (FieldPtr)GetObjectPtr(InputEntryField);
                    FldSetTextHandle(fp, 0);
                    FrmReturnToForm(0);
                    handled = true;
                    break;
                }

                case InputCancelButton:
                    inputDone = true;
                    inputRet = NULL;
                    FrmReturnToForm(0);
                    handled = true;
                    break;

            }
            break;

        case frmOpenEvent: {
            frmP = FrmGetActiveForm();
            InputFormInit(frmP);
            FrmDrawForm(frmP);
            FldGrabFocus((FieldPtr)GetObjectPtr(InputEntryField));
            FrmSetFocus(frmP, FrmGetObjectIndex(frmP, InputEntryField));
            handled = true;
            break;
        }			
    }
    return handled;
}

short FInputx, FInputy, FInputw, FInputh;
#define MAX_INPUTLEN 256
static void FInputInit(FormPtr pForm) {
    FieldPtr fp = (FieldPtr)GetObjectPtr(FInputFloatField);
    inputRet = (Handle)h_malloc(MAX_INPUTLEN);
    short len;
    
    if (!inputRet) vm_error("Out of memory",-1);
    if (defValue) {
        char* pir = (char*)MemHandleLock(inputRet);
        strncpy(pir, defValue, MAX_INPUTLEN-1);
        pir[MAX_INPUTLEN-1] = '\0';
        len = strlen(pir);
        MemHandleUnlock(inputRet);
    } else {
        ((char*)MemHandleLock(inputRet))[0] = '\0';
        MemHandleUnlock(inputRet);
    }
    FldSetTextHandle(fp, inputRet);
    if (defValue) {
        FldSetSelection(fp, 0, len);
    }
        
    WinHandle hWnd = FrmGetWindowHandle(pForm);
    RectangleType rect;

    // Move the window
    RctSetRectangle(&rect, FInputx, FInputy, FInputw+22, FInputh * 12 + 2);
    WinSetWindowBounds(hWnd, &rect);
    
    // Resize the field
    RctSetRectangle(&rect, 2, 1, FInputw, FInputh * 12);
    FrmSetObjectBounds(pForm, FrmGetObjectIndex(pForm, FInputFloatField), &rect);
    
    // Move the OK button
    RctSetRectangle(&rect, FInputw + 4, 2, 16, 10);
    FrmSetObjectBounds(pForm, FrmGetObjectIndex(pForm, FInputOKButton), &rect);
    
    // Move GSI
    /*
    if (FInputh > 1) {
        RctSetRectangle(&rect, FInputw + 6, FInputh * 12 - 10, 12, 12);
        FrmSetObjectBounds(pForm, FrmGetObjectIndex(pForm, FInputGraffitiShift), &rect);
    }*/
}

static Boolean FInputFormHandleEvent(EventPtr eventP) {
    Boolean handled = false;
    FormPtr frmP;

    switch (eventP->eType) {
        case ctlSelectEvent:
            if (eventP->data.ctlSelect.controlID == FInputOKButton) {
                inputDone = true;
                FieldPtr fp = (FieldPtr)GetObjectPtr(FInputFloatField);
                FldSetTextHandle(fp, 0);
                FrmReturnToForm(0);
                handled = true;
                break;
            }

        case frmOpenEvent: {
            frmP = FrmGetActiveForm();
            FInputInit(frmP);
            FrmDrawForm(frmP);
            FldGrabFocus((FieldPtr)GetObjectPtr(FInputFloatField));
            FrmSetFocus(frmP, FrmGetObjectIndex(frmP, FInputFloatField));
            handled = true;
            break;
        }
            
        /*case frmCloseEvent: {
            FieldPtr fp = (FieldPtr)GetObjectPtr(InputEntryField);
            FldSetTextHandle(fp, 0);
        }*/
            
    }
    return handled;
}

void DoFunction(char* name, bool isfunc);

struct DocHeader {
    //UInt16 version;
    UInt8 crap;
    UInt8 version;
    UInt16 spare;
    UInt32 len;
    UInt16 nRecs;
    UInt16 maxRecSize;
    UInt32 position;
};

// load a doc file into the temporary database, and return the index
// 0 on failure
UInt16 LoadDoc(char* name) {
    UInt16 recID = 0, ret = 0;
    Handle hHdr = NULL, hFlat = NULL, hRec;
    DocHeader* pHdr = NULL;
    unsigned char* pFlat = NULL, * pRec = NULL;
    UInt16 iFlat = 0;

    // open the database
    LocalID lid = DmFindDatabase(0, name);
    assert(lid);
    DmOpenRef docRef = DmOpenDatabase(0, lid, dmModeReadWrite);
    
    // read the header
    hHdr = DmQueryRecord(docRef, 0);
    pHdr = (DocHeader*)MemHandleLock(hHdr);
    
    if (pHdr->version != 1 && pHdr->version != 2)
        goto errorCleanup;
    
    // create the flattened record
    recID = dmMaxRecordIndex;
    hFlat = DmNewRecord(PcDB, &recID, pHdr->len+1);
    if (!hFlat) {
        recID = 0;
        goto errorCleanup;
    }
    
    pFlat = (unsigned char*)MemHandleLock(hFlat);
    
    StrPrintF(msg, "Loading %s...", name);
    DoFunction(msg, false);

    for (short iRec=0;iRec<pHdr->nRecs;iRec++) {
        hRec = DmQueryRecord(docRef, iRec+1);
        pRec = (unsigned char*)MemHandleLock(hRec);
        long len = MemHandleSize(hRec);
        
        if (pHdr->version == 1) {
            // uncompressed
            DmWrite(pFlat, iFlat, pRec, len);
            iFlat += len;
            
        } else {
            long i = 0;
            while (i < len) {
                unsigned char c = pRec[i++];
                
                // space then char
                if (c >= 0xc0) {
                    unsigned char space = ' ';
                    DmWrite(pFlat, iFlat, &space, 1);
                    iFlat++;
                    c = c^0x80;
                }
                // pass-thru
                if (c == 0 || (c >= 0x09 && c <= 0x7f)) {
                    DmWrite(pFlat, iFlat, &c, 1);
                    iFlat++;
                // literal
                } else if (c >= 0x01 && c <= 0x08) {
                    DmWrite(pFlat, iFlat, pRec + i, c);
                    iFlat += c;
                    i += c;
                // copy
                } else {
                    UInt16 offset = (c << 8) | pRec[i++];
                    offset &= 0x3fff;
                    short clen = (offset & 0x07) + 3;
                    offset >>= 3;
                    while (clen--) {
                        DmWrite(pFlat, iFlat, pFlat + iFlat-offset, 1);
                        iFlat++;
                    }
                }
            }
        }
        MemHandleUnlock(hRec);
    }
    
    
    // NULL terminate, just in case
    DmSet(pFlat, iFlat, 1, '\0');

    ret = recID;
errorCleanup:
    if (pHdr) MemHandleUnlock(hHdr);
    DmCloseDatabase(docRef);
    if (pFlat) {
        MemHandleUnlock(hFlat);
        DmReleaseRecord(PcDB, recID, true);
    }
    return ret;
}

short FindMemo(char* name, bool prog) {
    // This assumes that the DB is already open!!!
    Handle h_memo;
    short id = -1;
    char* memo;
    char mname[128];


    UInt numRecs = DmNumRecords(memoDB);
    if (!numRecs) goto cleanUp;
    
    for (UInt i=0;i<numRecs;i++) {
        Word attr; // It's supposed to be a Byte
        ULong uid;
        LocalID lid;

        DmRecordInfo(memoDB, i, &attr, &uid, &lid);
        if (attr & (dmRecAttrDelete | dmRecAttrSecret)) continue; // Record is either secret or trashed
        h_memo = (Handle)DmQueryRecord(memoDB, i);
        memo = (char*)MemHandleLock(h_memo);
        if (!prog || (*memo=='/' && (*(memo+1)=='/') || *(memo+1)=='$')) {
            char* t = memo + (prog ? 2 : 0);
            while (*t && *t!='\n' && (*t=='\t' || *t==' ')) t++;
            if (!*t || *t=='\n') {
                goto closeRec;
            }
            short si=0;
            while (*t && *t!='\n' && si<128) mname[si++] = *t++;
            mname[si--]='\0';
            while (si && (mname[si]==' ' || mname[si]=='\t')) mname[si--]='\0';
            if (!strcmp(name, mname)) {
                id = i;
                MemHandleUnlock(h_memo);
                goto cleanUp;
            }
        }
    closeRec:
        MemHandleUnlock(h_memo);
    }
cleanUp:
    return id;
}

#ifndef POCKETC_RUNTIME
void DoAddin(char* name) {
    cStrings = (char*)MemHandleLock(strings_h);
    pLibs->lock();

    for (short i=0; i<libNum;i++) {
        if (StrCompare(name, &cStrings[(*pLibs)[i].name])==0) {
            // Library already loaded
            pLibs->unlock();
            MemHandleUnlock(strings_h);
            return;
        }
    }
    pLibs->unlock();
    MemHandleUnlock(strings_h);
    
    char* osrc = source;
    int oline = currLine;
    bool failed = false;
    
    MemHandle hAddIn = NULL;
    LocalID lid = NULL;
    DmOpenRef dbRef = NULL;
    
    // open header
    if (*name != '\0') {
        // load addin database by name
        UInt16 card = 0;
        lid = MyFindDatabase(name, byref card);
        if (lid) {
            dbRef = DmOpenDatabase(card, lid, dmModeReadOnly);
            if (dbRef) {
                hAddIn = DmGetResource('pcNH', 0);
                if (!hAddIn) DmCloseDatabase(dbRef);
            }
        }
    } else {
        // addin is PocketC
        hAddIn = DmGetResource('pcNH', 0);
    }
    
    if (hAddIn) {
        // setup lexer
        currLine = 0;
        source = (char*)MemHandleLock(hAddIn);

        // catch any parser exceptions, since we don't have the include stack
        // setup in the usual memo/doc way
        ErrTry {
            LibraryInfo li;
            li.bLib = true;
            li.resid = 0xffff;
            li.name = addString(name);

            nextToken();
            char func[32];
            VarType args[10];
            int nArgs;

            // parse header
            while (tok.id == tiIdent || tok.id == tiAt || tok.id == tiAddinResId) {
                if (tok.id == tiAddinResId) {
                    nextToken();
                    if (tok.id != tiConstInt) ErrThrow(0);
                    
                    // new "add-in"
                    li.resid = tok.intVal;
                    libNum++;
                    libFuncNum = 0;
                    pLibs->add(li);
                    nextToken();
                    continue;
                } else if (tok.id == tiAt) {
                    nextToken(); // @
                    nextToken(); // doc
                    nextToken(); // "doc string"
                    nextToken(); // ;
                    continue;
                }
                if (li.resid == 0xffff) ErrThrow(0); // throw random error
                nArgs = 0;
                MemSet(args, sizeof(args), vtInt);
                strcpy(func, tok.value);
                nextToken();
                if (tok.id != tiLParen) goto handleError;
                nextToken();
                while (tok.id >= tiInt && tok.id <= tiString) {
                    args[nArgs++] = varType(tok.id);
                    nextToken();
                    if (tok.id != tiIdent) goto handleError;
                    nextToken();
                    if (tok.id == tiRParen) break;
                    if (tok.id != tiComma) goto handleError;
                    nextToken();
                }
                if (tok.id != tiRParen) goto handleError;
                nextToken();
                if (tok.id != tiSemiColon) goto handleError;
                nextToken();
                addLibFunc(func, nArgs, args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8], args[9]);
            }
        }
        ErrCatch(err) {
            failed = true;
        } ErrEndCatch

cleanupHeader:
        // close header
        MemHandleUnlock(hAddIn);
        DmReleaseResource(hAddIn);
        if (dbRef)
            DmCloseDatabase(dbRef);

        // return the lexer to previous state
        source = osrc;
        currLine = oline;
        tok.id = tiComma; // not tiEnd
    } else {
        failed = true;
    }

    if (failed) c_error("unable to load add-in", tok.line);
    return;

handleError:
    failed = true;
    goto cleanupHeader;
}

void DoLibrary(char* name) {
    cStrings = (char*)MemHandleLock(strings_h);
    pLibs->lock();

    for (short i=0; i<libNum;i++) {
        if (StrCompare(name, &cStrings[(*pLibs)[i].name])==0) {
            // Library already loaded
            pLibs->unlock();
            MemHandleUnlock(strings_h);
            return;
        }
    }
    pLibs->unlock();
    MemHandleUnlock(strings_h);

    LibraryInfo li;
    li.bLib = true;
    li.resid = 0xffff;
    libNum++;
    libFuncNum = 0;
    UInt ref = LoadLib(name);
    if (!ref) c_error("unable to load library", tok.line);

    PocketCLibAddFunctions(ref);
    PocketCLibClose(ref, 0);
    SysLibRemove(ref);

    li.name = addString(name);
    pLibs->add(li);
}

void DoInclude(char* name) {
    char msg[300];
    
    bool bDoc = false;
    if (incLevel >= 3) c_error("only 3 levels of includes allowed", tok.line);

    short id = FindMemo(name, true);
    if (id < 0) {
        LocalID lid = DmFindDatabase(0, name);
        UInt32 dbType = 0, dbCreate = 0;
        if (lid) {
            DmDatabaseInfo(0, lid, 0,0,0,0,0,0,0,0,0, &dbType, &dbCreate);
        }
        if (dbType == 'TEXt' && dbCreate == 'REAd') {
            id = LoadDoc(name);
            if (!id) {
                StrPrintF(msg, "unable to load doc '%s'", name);
                c_error(msg, tok.line);
            }
            bDoc = true;
        } else {
            StrPrintF(msg, "unable to find '%s'", name);
            c_error(msg, tok.line);
        }
    }
    incLevel++;
    
    // open memo
    incStack[incLevel].id = id;
    incStack[incLevel].src_h = (Handle)DmQueryRecord(bDoc ? PcDB : memoDB, id);
    incStack[incLevel].isrc = incStack[incLevel].src = (char*)MemHandleLock(incStack[incLevel].src_h);
    incStack[incLevel].name[31] = 0;
    incStack[incLevel].bDoc = bDoc;
    strncpy(incStack[incLevel].name, name, 31);
    
    // save previous position
    incStack[incLevel-1].line = currLine;
    incStack[incLevel-1].src = source;

    source = incStack[incLevel].src;
    currLine = 1;
}

void EndInclude() {
    if (!incLevel) return;
    // close memo
    MemHandleUnlock(incStack[incLevel].src_h);
    //DmReleaseRecord(memoDB, incStack[incLevel].id, false); don't need, since we are querying
    if (incStack[incLevel].bDoc) {
        DmRemoveRecord(PcDB, incStack[incLevel].id);
    }

    incLevel--;
    // restore posistion
    currLine = incStack[incLevel].line;
    source = incStack[incLevel].src;
    
    tok.id = tiIf; // get rid of end of file
    //nextToken(); // get another token
}

void DoFunction(char* name, bool isfunc) {
    //char txt[50];
    
    if (isfunc)
        StrPrintF(msg, "Compiling %s()...", name);
    else
        strcpy(msg, name);
    FormPtr fp = FrmGetActiveForm();
    Word id = FrmGetObjectIndex(fp, CompileStatusLabel);
    FrmHideObject(fp, id);
    FrmCopyLabel(fp, CompileStatusLabel, msg);
    FrmShowObject(fp, id);
}


/***********************************************************************
 *
 *  Compile an Applet
 *
 ***********************************************************************/
extern ULong heapFree, heapMax;

// compile dialog data
vector<short> vNumFromList;
//vector<char*> vProgs(true);

void Compile(short sel) {
    bool gotoError = false;
    short errOffset = 0;
    short recID;
    bool bDoc = false;
    incLevel = 0;
    char name[32];

    memoDB = NULL;

#ifndef POCKETC_RETAIL
    errOffset = RegCheck();
    if (errOffset==1) FrmAlert(ExpiredAlert); // It's been used well
    if (errOffset==2) {
        FrmAlert(ExpiredPlusAlert); // It's been overused
        FrmGotoForm(MainForm);
        return;
    }
#endif
    errOffset=0;
    
    //volatile ULong size = MemHeapSize(0);
    //MemHeapFreeBytes(0, &heapFree, &heapMax);

    // Create status line
    FormPtr fp = FrmGetActiveForm();
    FrmHideObject(fp, FrmGetObjectIndex(fp, CompileCompileButton));
    FrmHideObject(fp, FrmGetObjectIndex(fp, CompileCancelButton));
    FrmCopyLabel(fp, CompileStatusLabel, "Compiling...");
    FrmShowObject(fp, FrmGetObjectIndex(fp, CompileStatusLabel));
    
    // data crap
    code = (unsigned char*)malloc(304); codePtr = 0; _codeSize = 0; codeOff = 0;
    reloc_h = h_malloc(sizeof(short)*128); _Labels = 128; nLabels=0;
    floats_h = h_malloc(sizeof(float)*10); _Floats=10; nFloats=0;

    global_h = h_malloc(sizeof(GlobalInfo)*10); nGlobals = 0; _global = 10;
    globalInits_h = h_malloc(sizeof(GlobalInit)*10); nGlobalInits = 0; _globalInits = 10;
    local_h = h_malloc(sizeof(LocalInfo)*10); _local = 10;
    func_h = h_malloc(sizeof(FuncInfo)*10); nFuncs=0; _func = 10;
    macro_h = h_malloc(sizeof(Macro)*10); nMacros = 0; _macro = 10;
    macrod_h = h_malloc(20); nMacrod = 0; _macrod = 20;
    pLibs = new hvector<LibraryInfo>;
    pLibs->init();

    if (!reloc_h || !func_h || !local_h || !global_h || !floats_h || !macro_h || !macrod_h || !pLibs) {
        FrmCustomAlert(CompilerErrorAlert, "Error pre-allocating compiler memory. (Out of memory)", NULL, NULL);
        goto compileCleanup;
    }

    // load memo
    memoDB = DmOpenDatabaseByTypeCreator('DATA', 'PMem', dmModeReadOnly);
    if (!memoDB)
        memoDB = DmOpenDatabaseByTypeCreator('DATA', sysFileCMemo, dmModeReadOnly);
    if (!memoDB) Alert("No Memo Database!?!");
    
    recID = vNumFromList[sel];
    if (recID != -1) {
        incStack[0].bDoc = false;
        incStack[0].id = recID;
        incStack[0].src_h = (Handle)DmQueryRecord(memoDB, recID);
        source = incStack[0].isrc = incStack[0].src = (char*)MemHandleLock(incStack[0].src_h);
    } else {
        incStack[0].bDoc = true;
        incStack[0].id = recID = LoadDoc(vNames[sel]);
        if (!recID) {
            Alert("Unable to load document");
            goto compileCleanup;
        }
        incStack[0].src_h = (Handle)DmQueryRecord(PcDB, recID);
        source = incStack[0].isrc = incStack[0].src = (char*)MemHandleLock(incStack[0].src_h);
        if (*source != '/' || *(source+1) != '/') {
            Alert("Document must begin with '//'");
            MemHandleUnlock(incStack[0].src_h);
            DmRemoveRecord(PcDB, recID);
            goto compileCleanup;
        }
    }
    strcpy(incStack[0].name, vNames[sel]);

    short nPtr=0;
    char* src = source+2;
    while (*src==' ' || *src=='\t') src++;
    while (*src && *src!='\n' && nPtr<31) name[nPtr++] = *src++;
    name[nPtr]='\0';
    strcpy(lastApplet, name);


    // create output database
    LocalID dbid = DmFindDatabase(0, name);
    ULong dbType, dbCreate;
    UInt attr = 0;
    if (dbid) {
        DmDatabaseInfo(0, dbid, 0,&attr,0,0,0,0,0,0,0, &dbType, &dbCreate);
        if (dbType!=appVMDBType || dbCreate!=appFileCreator) {
            FrmCustomAlert(CompilerErrorAlert, "Duplicate database name", NULL, NULL);
            MemHandleUnlock(incStack[0].src_h);
            if (incStack[0].bDoc)
                DmRemoveRecord(PcDB, recID);
            goto compileCleanup;
        } else DmDeleteDatabase(0, dbid);
    }

    Err e = DmCreateDatabase(0, name, appFileCreator, appVMDBType, false);
    if (e) {
        FrmCustomAlert(CompilerErrorAlert, "Unable to create code database", NULL, NULL);
        goto compileCleanup;
    }
    dbid = DmFindDatabase(0, name);
    codeDB = DmOpenDatabase(0, dbid, dmModeReadWrite);

    UInt index = 0;
    VoidHand dbh;
    VoidPtr dbp;
    code_h = DmNewRecord(codeDB, &index, sizeof(short));
    index = 1;
    dbh = DmNewRecord(codeDB, &index, 4); DmReleaseRecord(codeDB, 1, false);
    index = 2;
    strings_h = (Handle)DmNewRecord(codeDB, &index, 256+sizeof(short));
    _StrChars = 256; nStrChars=0;
    dbgLoc = 0;

    // add the predefined macros
    short md = nMacrod;
    addMacroByte(tiConstInt); addMacroInt(1); addMacro("__PKTC_PALM__", 1, md);
    md = nMacrod;
    addMacroByte(tiConstInt); addMacroInt(1); addMacro("__PKTC__", 1, md);
    

    ErrTry {
        parse();
        DoFunction("Fixing JMP* addresses", false);
        relocate();
    }
    ErrCatch (err) {
        errOffset = (short)(source - incStack[incLevel].isrc);
        recID = incStack[incLevel].id;
        bDoc = incStack[incLevel].bDoc;
        strcpy(name, incStack[incLevel].name);
        while (incLevel >= 0) {
            MemHandleUnlock(incStack[incLevel].src_h);
            if (incStack[incLevel].bDoc) {
                DmRemoveRecord(PcDB, incStack[incLevel].id);
            }
            incLevel--;
        }

RemoveCorruptDB:
        // close and delete the invalid database
        DmReleaseRecord(codeDB, 0, true);
        DmReleaseRecord(codeDB, 2, true);
        DmCloseDatabase(codeDB);
        DmDeleteDatabase(0, dbid);

        DmCloseDatabase(memoDB);
        memoDB = NULL;
        if (err == 4) gotoError = true;
        goto compileCleanup;
    } ErrEndCatch

    while (incLevel >= 0) {
        MemHandleUnlock(incStack[incLevel].src_h);
        //DmReleaseRecord(memoDB, incStack[incLevel].id, false);
        if (incStack[incLevel].bDoc) {
            DmRemoveRecord(PcDB, incStack[incLevel].id);
        }
        incLevel--;
    }
    DmCloseDatabase(memoDB);
    memoDB = NULL;

    short type, asize;

    // write code segment
    unsigned short scodeOff = codeOff & 0xffff;
    DmWrite(MemHandleLock(code_h), 0, &scodeOff, sizeof(short));
    MemHandleUnlock(code_h);
    DmReleaseRecord(codeDB, 0, true);

    // write const floats segment
    index = 1;
    dbh = DmResizeRecord(codeDB, index, sizeof(float)*nFloats+sizeof(short));
    if (dbh) 
        dbh = DmGetRecord(codeDB, index);
    if (dbh) {
        DmWrite(dbp = MemHandleLock(dbh), 0, &nFloats, sizeof(short));
        cFloats = (float*)MemHandleLock(floats_h);
        DmWrite(dbp, sizeof(short), cFloats, sizeof(float)*nFloats);
        MemHandleUnlock(dbh);
        MemHandleUnlock(floats_h);
        DmReleaseRecord(codeDB, 1, true);
    } else {
        Alert("Out of DB storage");
        goto RemoveCorruptDB;
    }
   
    // write const strings segment
    index = 2;
    cStrings = (char*)MemHandleLock(strings_h);
    DmWrite(cStrings, 0, &nStrChars, sizeof(short));
    MemHandleUnlock(strings_h);
    DmResizeRecord(codeDB, 2, nStrChars+sizeof(short));
    DmReleaseRecord(codeDB, 2, true);

    // write global type info
    index = 3;
    dbh = DmNewRecord(codeDB, &index, sizeof(short)*(nGlobals*2+2 + nGlobalInits*4+1));
    if (!dbh) {
        Alert("Out of DB storage!");
        goto RemoveCorruptDB;
    }
   
    short* gd = (short*)MemHandleLock(dbh);
    DmWrite(gd, 0, &nGlobals, sizeof(short));
    DmWrite(gd, sizeof(short), &globalOff, sizeof(short));
    globalI = (GlobalInfo*)MemHandleLock(global_h);
    for (short gi=0;gi<nGlobals;gi++) {
        type = (short)globalI[gi].type;
        DmWrite(gd, (gi*2+2)*sizeof(short), &type, sizeof(short));
        asize = globalI[gi].arraySize;
        if (!asize) asize=1;
        DmWrite(gd, (gi*2+3)*sizeof(short), &asize, sizeof(short));
    }

    short goff = nGlobals * 2 + 2;
    DmWrite(gd, goff * sizeof(short), &nGlobalInits, sizeof(short));

    globalInit = (GlobalInit*)MemHandleLock(globalInits_h);
    for (short gi=0;gi<nGlobalInits;gi++) {
        DmWrite(gd, (goff + gi*4 + 1) * sizeof(short), &globalInit[gi].offset, sizeof(short));
        short temp = globalInit[gi].type;
        DmWrite(gd, (goff + gi*4 + 2) * sizeof(short), &temp, sizeof(short));
        temp = globalInit[gi].val >> 16;
        DmWrite(gd, (goff + gi*4 + 3) * sizeof(short), &temp, sizeof(short));
        temp = globalInit[gi].val & 0xffff;
        DmWrite(gd, (goff + gi*4 + 4) * sizeof(short), &temp, sizeof(short));
    }

    MemHandleUnlock(dbh);
    MemHandleUnlock(global_h);
    MemHandleUnlock(globalInits_h);
    DmReleaseRecord(codeDB, 3, true);
    DmCloseDatabase(codeDB);
    if (attr & dmHdrAttrBackup) { // Attributes of previously deleted DB
        // We need to set the backup bit
        DmDatabaseInfo(0, dbid, 0, &attr, 0,0,0,0,0,0,0,0,0);
        attr |= dmHdrAttrBackup;
        DmSetDatabaseInfo(0, dbid, 0, &attr, 0,0,0,0,0,0,0,0,0);
    }
    //Alert("Compilation successful");   
   
    // delete data crap
compileCleanup:
    if (memoDB) {
        DmCloseDatabase(memoDB);
        memoDB = NULL;
    }
    currLine=0;
    tok.id = tiIf; // ensure that it is not tiEnd
    if (func_h) h_free(func_h);
    if (global_h) h_free(global_h);
    if (globalInits_h) h_free(globalInits_h);
    if (local_h) h_free(local_h);
    if (floats_h) h_free(floats_h);
    if (macro_h) h_free(macro_h);
    if (macrod_h) h_free(macrod_h);
    if (reloc_h) h_free(reloc_h);
    //if (code_h) h_free(code_h); // this is deleted when the DB is deleted
    if (code) free(code);
    if (pLibs) delete pLibs;

    if (gotoError) {
        if (bDoc) {
            GoToParamsPtr gp = (GoToParamsPtr)MemPtrNew(sizeof(GoToParamsType));
            MemSet(gp, sizeof(GoToParamsType), 0);
            MemPtrSetOwner(gp, 0); // The guy at Palm Computing said to do this! :)
            gp->dbID = DmFindDatabase(0, name);
            gp->matchCustom = errOffset - 1;
            gp->searchStrLen = -1;
            LocalID id = DmFindDatabase(0, prefs.docApp);
            if (id) {
                SysUIAppSwitch(0, id, sysAppLaunchCmdGoTo, (Ptr)gp);
            } else {
                FrmGotoForm(MainForm);
                prefs.selProg = -1;
            }
            
        } else {
            GoToParamsPtr gp = (GoToParamsPtr)MemPtrNew(sizeof(GoToParamsType));
            MemPtrSetOwner(gp, 0); // The guy at Palm Computing said to do this! :)
            gp->dbID = DmFindDatabase(0, "MemosDB-PMem");
            if (!gp->dbID)
                gp->dbID = DmFindDatabase(0, "MemoDB");
            gp->dbCardNo = 0;
            gp->recordNum = recID;
            gp->matchPos = errOffset - 1;
            gp->searchStrLen = gp->matchCustom = 1;
            LocalID id = DmFindDatabase(0, prefs.memoApp);
            if (!id) id = DmFindDatabase(0, "Memos-PMem");
            if (!id) id = DmFindDatabase(0, "Memo Pad");

            SysUIAppSwitch(0, id, sysAppLaunchCmdGoTo, (Ptr)gp);
        }
    } else {
        FrmGotoForm(MainForm);
        prefs.selProg = -1;
    }
}

/***********************************************************************
 *
 *  CompileForm
 *
 ***********************************************************************/

bool hasExt(char* name, char* ext) {
    short nLen = strlen(name);
    short nExt = strlen(ext);
    if (nExt > nLen) return false;
    return (0 == strcmp(name + nLen-nExt, ext));
}

static void CompileFormInit(FormPtr) {
    Handle h_memo;
    char* memo;
    char* name;
    short nProgs=0;
    memoDB = DmOpenDatabaseByTypeCreator('DATA', 'PMem', dmModeReadOnly);
    if (!memoDB)
        memoDB = DmOpenDatabaseByTypeCreator('DATA', sysFileCMemo, dmModeReadOnly);
    if (!memoDB) Alert("No Memo Database!?!");

    UInt numRecs = DmNumRecords(memoDB);
    if (!numRecs) goto memoCleanUp;

    for (short i=0;i<numRecs;i++) {
        Word attr; // It's supposed to be a Byte
        ULong uid;
        LocalID lid;
        DmRecordInfo(memoDB, i, &attr, &uid, &lid);
        if (attr & (dmRecAttrDelete | dmRecAttrSecret)) continue; // Record is either secret or trashed
        h_memo = (Handle)DmQueryRecord(memoDB, i);
        memo = (char*)MemHandleLock(h_memo);
        if (*memo=='/' && *(memo+1)=='/') {
            char* t = memo;
            while (*t && *t!='\n') t++;
            name = (char*)MemPtrNew(t-memo+2);
            ErrFatalDisplayIf(!name, "Error initializing Compile form");
            t = memo+2;
            while (*t && *t!='\n' && (*t=='\t' || *t==' ')) t++;
            if (!*t || *t=='\n') {
                MemPtrFree(name);
                goto closeRec;
            }
            short si=0;
            while (*t && *t!='\n') name[si++] = *t++;
            name[si]='\0';
            vNames.add(name);
            vNumFromList.add(i);
        }
    closeRec:
        MemHandleUnlock(h_memo);
    }
memoCleanUp:
    DmCloseDatabase(memoDB);

    DmSearchStateType ss;
    LocalID lid;
    UInt card;
    
    if (!DmGetNextDatabaseByTypeCreator(true, &ss, 'TEXt', 'REAd', false, &card, &lid)) {
        do {
            name = new char[32];
            ErrFatalDisplayIf(!name, "Error initializing DOC list");
            DmDatabaseInfo(card, lid, name, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
            if (hasExt(name, ".c") || hasExt(name, ".pc")) {
                vNames.add(name);
                short x=-1;
                vNumFromList.add(x);
            } else {
                delete name;
                name = NULL;
            }
            
        } while (!DmGetNextDatabaseByTypeCreator(false, &ss, 'TEXt', 'REAd', false, &card, &lid));
    }

    short iLastApp = -1;
    for (short i=0;i<vNames.size();i++) {
        if (strcmp(vNames[i], prefs.lastApp) == 0) {
            iLastApp = i;
            break;
        }
    }
    
    if (iLastApp != -1) {
        char* prevName = vNames[iLastApp];
        short prevIndex = vNumFromList[iLastApp];
        for (short i=iLastApp; i>0; i--) {
            char* tempName = vNames[i];
            short tempNum = vNumFromList[i];
            vNames[i] = vNames[i-1];
            vNumFromList[i] = vNumFromList[i-1];
        }
        vNames[0] = prevName;
        vNumFromList[0] = prevIndex;
    }

    ListPtr lp = (ListPtr)GetObjectPtr(CompileMemoList);
    if (vNames.size()) {
        LstSetListChoices(lp, vNames.lock(), vNames.size());
    }
}

static Boolean CompileFormHandleEvent(EventPtr	eventP)	{
    Boolean	handled	= false;
    FormPtr	frmP;

    if (HandleResizeEvent(FrmGetActiveFormID(), eventP))
        return true;

    ListPtr	lp = (ListPtr)GetObjectPtr(CompileMemoList);
    short sel =	LstGetSelection(lp);

    switch (eventP->eType) {
        case ctlSelectEvent:
            switch (eventP->data.ctlSelect.controlID) {
                case CompileCompileButton: {
                    if (!vNames.size())	break;
                    //strcpy(lastApplet, vNames[sel]); // remember the applet name
                    strncpy(prefs.lastApp, vNames[sel],	32);
                    prefs.lastApp[31] =	0;
                    Compile(sel);
                    vNames.clear();
                    vNumFromList.clear();
                    handled	= true;
                    break;
                }

                case CompileCancelButton:
                    vNumFromList.clear();
                    FrmGotoForm(MainForm);
                    vNames.clear();
                    handled	= true;
                    break;

            }
            break;

        case keyDownEvent:
            if (eventP->data.keyDown.chr==pageUpChr) {
                LstScrollList(lp, winUp, 9);
                LstEraseList(lp);
                LstDrawList(lp);
                handled = true;
            } else if (eventP->data.keyDown.chr==pageDownChr) {
                LstScrollList(lp, winDown, 9);
                LstEraseList(lp);
                LstDrawList(lp);
                handled = true;
            }
            break;

        case frmOpenEvent:
            frmP = FrmGetActiveForm();
            CompileFormInit(frmP);
            FrmDrawForm	(frmP);
            handled	= true;
            break;
    }
    return handled;
}

#endif

/***********************************************************************
 *
 *  DatabaseForm
 *
 ***********************************************************************/
#ifndef POCKETC_FAT
short nDBs = 0;
char** dbnames = NULL;
static void DatabaseFormInit(FormPtr) {
    DmSearchStateType ss;
    LocalID lid;
    UInt card, attr;
    ListPtr lst;
    //short nProgs = 0;
    short i=0;
    
    //nProgs = 32;
    if (dbnames) {
        for (short j=0;j<nDBs;j++) if (dbnames[j]) delete[] dbnames[j];
        delete[] dbnames;
    }
    nDBs = 0;
    dbnames = NULL;
    if (DmGetNextDatabaseByTypeCreator(true, &ss,
        appUserDBType, appFileCreator, false, &card, &lid)) goto endListFill;

    if (!DmGetNextDatabaseByTypeCreator(true, &ss,	appUserDBType, appFileCreator,
        false, &card, &lid)) {
        do {
            nDBs++;
        } while (!DmGetNextDatabaseByTypeCreator(false, &ss,
            appUserDBType, appFileCreator, false, &card, &lid));
    }

    dbnames = new char*[nDBs];
    ErrFatalDisplayIf(!dbnames, "Error initializing Database form");
    for (short i=0;i<nDBs;i++) dbnames[i] = NULL; //new char[32];

    i = 0;
    DmGetNextDatabaseByTypeCreator(true, &ss,	appUserDBType, appFileCreator,
        false, &card, &lid);
    do {
        dbnames[i] = new char[32];
        ErrFatalDisplayIf(!dbnames[i], "Error initializing Database form");
        DmDatabaseInfo(card, lid, dbnames[i], &attr,
            NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
        if (attr & (dmRecAttrSecret | dmRecAttrDelete)) continue;
        i++;
    } while (!DmGetNextDatabaseByTypeCreator(false, &ss,
        appUserDBType, appFileCreator, false, &card, &lid));

endListFill:
    lst = (ListPtr)GetObjectPtr(DatabaseDatabaseList);
    LstSetListChoices(lst, dbnames, i);
    //LstDrawList(lst);
}


static Boolean DatabaseFormHandleEvent(EventPtr	eventP)	{
    Boolean	handled	= false;
    ListPtr	lst;
    FormPtr	frmP;

    switch (eventP->eType) {
        case ctlSelectEvent:
            switch (eventP->data.ctlSelect.controlID) {
                case DatabaseDeleteButton: {
                    ListPtr	lp = (ListPtr)GetObjectPtr(DatabaseDatabaseList);
                    short sel =	LstGetSelection(lp);
                    if (sel<0) break;
                    
                    char* name = LstGetSelectionText(lp, sel);
                    if (FrmCustomAlert(DeleteAlert,	name, NULL,	NULL)) break;
                    LocalID	ld = DmFindDatabase(0, name);
                    if (ld)	DmDeleteDatabase(0,	ld);
                    DatabaseFormInit(FrmGetActiveForm());
                    LstDrawList(lp);
                    handled	= true;
                    break;
                }

                case DatabaseCancelButton:
                    FrmReturnToForm(MainForm);
                    FillDBList(true);
                    handled	= true;

                    if (dbnames) {
                        for	(short j=0;j<nDBs;j++) if (dbnames[j]) delete[]	dbnames[j];
                        delete[] dbnames;
                    }
                    dbnames	= NULL;
                    break;

            }
            break;

        case keyDownEvent:
            lst	= (ListPtr)GetObjectPtr(DatabaseDatabaseList);
            if (eventP->data.keyDown.chr==pageUpChr) {
                LstScrollList(lst, winUp, 9);
                LstEraseList(lst);
                LstDrawList(lst);
                handled = true;
            } else if (eventP->data.keyDown.chr==pageDownChr) {
                LstScrollList(lst, winDown, 9);
                LstEraseList(lst);
                LstDrawList(lst);
                handled = true;
            }
            break;

/*		  case keyDownEvent:
            if (eventP->data.keyDown.chr==pageUpChr) {
                ; // These should scroll the list, maybe
            } else if (eventP->data.keyDown.chr==pageUpChr)	{
                ; // These should scroll the list, maybe
            }
            break;
*/
        case frmOpenEvent:
            frmP = FrmGetActiveForm();
            DatabaseFormInit(frmP);
            FrmDrawForm	(frmP);
            handled	= true;
            break;
            
        case frmCloseEvent:
                break; // don't	say	we handled the event
    }
    return handled;
}
#endif

/***********************************************************************
 *
 * FUNCTION:	AppHandleEvent
 *
 * DESCRIPTION:	This routine loads form	resources and set the event
 *				handler	for	the	form loaded.
 *
 * PARAMETERS:	event  - a pointer to an EventType structure
 *
 * RETURNED:	true if	the	event has handle and should	not	be passed
 *				to a higher	level handler.
 *
 * REVISION	HISTORY:
 *
 ***********************************************************************/
static Boolean AppHandleEvent(EventPtr eventP) {
    Word formId;
    FormPtr	frmP;

    if (eventP->eType == frmLoadEvent) {
        // Load	the	form resource.
        formId = eventP->data.frmLoad.formID;
        frmP = FrmInitForm(formId);
        FrmSetActiveForm(frmP);
        if (formId != GraphForm || enableResize)
            SetFormDIAPolicy(formId);
        // Set the event handler for the form.	The	handler	of the currently
        // active form is called by	FrmHandleEvent each	time is	receives an
        // event.
        switch (formId)	{
            case OutputForm:
                FrmSetEventHandler(frmP, OutputFormHandleEvent);
                break;
#ifndef	POCKETC_FAT
            case MainForm:
                FrmSetEventHandler(frmP, MainFormHandleEvent);
                break;
            case AboutForm:
                FrmSetEventHandler(frmP, AboutFormHandleEvent);
                break;
            case DatabaseForm:
                FrmSetEventHandler(frmP, DatabaseFormHandleEvent);
                break;
#endif
#ifndef	POCKETC_RUNTIME
            case RegisterForm:
                FrmSetEventHandler(frmP, RegisterFormHandleEvent);
                break;
            case CompileForm:
                FrmSetEventHandler(frmP, CompileFormHandleEvent);
                break;
            case EditorOptionsForm:
                FrmSetEventHandler(frmP, EOFormHandleEvent);
                break;
#endif
            case InputForm:
                FrmSetEventHandler(frmP, InputFormHandleEvent);
                break;
            case FInputForm:
                FrmSetEventHandler(frmP, FInputFormHandleEvent);
                break;
            case GraphForm:
                FrmSetEventHandler(frmP, GraphFormHandleEvent);
                break;
            default:
                //ErrNonFatalDisplay("Invalid Form Load	Event");
                break;
        }
        return true;
    }
    return false;
}

/***********************************************************************
 *
 * FUNCTION:	AppEventLoop
 *
 ***********************************************************************/
static void	AppEventLoop(void)
{
    Word error;
    EventType event;

    do {
        EvtGetEvent(&event,	evtWaitForever);
        if (! SysHandleEvent(&event))
            if (! MenuHandleEvent(0, &event, &error))
                if (! AppHandleEvent(&event))
                    FrmDispatchEvent(&event);
    } while	(event.eType !=	appStopEvent);
}

void EventQueue::AddEvent(short type, short v1, short v2) {
    // don't add duplicates for some events
    if (nEvents > 0) {
        if (events[nEvents-1].type == eqNone) {
            nEvents--; // get rid of the nil event if another event is coming in
        }
    }
    
    // if this is resize, remove any pending resize or update events
    if (type == eqResize && nEvents) {
        for (short i=0; i<nEvents; i++) {
            if (events[i].type == eqResize || events[i].type == eqUpdate) {
                if (i != nEvents-1) {
                    memcpy(&events[i], &events[i+1], (nEvents - i - 1) * sizeof(EventItem));
                }
                nEvents--;
                break;
            }
        }
    }
    
    // queue is full
    if (nEvents == maxEvents) {
        short iEntry = 0;
        // if the top event is the same as the new event, but not a key event
        // just replace it
        if (events[nEvents-1].type == type) {
            if (type != eqKey) {
                events[nEvents-1].v1 = v1;
                events[nEvents-1].v2 = v2;
                return;
            }
        }
        
        if (type == eqPenMove) return;
        
        for (short i=0; i<nEvents-1; i++) {
            if (events[i].type == events[i+1].type && events[i].type != eqKey) {
                iEntry = i;
                break;
            }
            if (events[i].type == eqPenMove) iEntry = i; // remove a pen move if nothing else is found
        }

        if (iEntry < nEvents-1) {		
            memcpy(&events[iEntry], &events[iEntry+1], (nEvents - iEntry - 1) * sizeof(EventItem));
        }
    } else {
        nEvents++;
    }
        
    events[nEvents-1].type = type;
    events[nEvents-1].v1 = v1;
    events[nEvents-1].v2 = v2;
}

bool EventQueue::PopEvent() {
    if (nEvents) {
        type = events[0].type;
        v1 = events[0].v1;
        v2 = events[0].v2;
        if (type == eqResize) {
            // replace with a redraw event
            events[0].type = eqUpdate;
            events[0].v1 = events[0].v2 = 0;
        } else {
            memcpy(&events[0], &events[1], (nEvents - 1) * sizeof(EventItem));
            nEvents--;
        }
        return true;
    }
    return false;
}

void EventQueue::Clear() {
    nEvents = 0;
    type = v1 = v2 = 0;
}

void EventQueue::RemoveInput() {
    short i = nEvents;
    while (i--) {
        if (events[i].type == eqPenUp || events[i].type == eqPenDown || events[i].type == eqKey) {
            if (i != nEvents - 1)
                memcpy(&events[i], &events[i+1], (nEvents - i - 1) * sizeof(events[0]));
            nEvents--;
        }
    }
}

/***********************************************************************
 *
 *   UIYield() -- Allow PalmOS events to filter through during any point
 *   of program execution.
 *
 *   if blocking is true, UIYield will get one event and return,
 *   if blocking is false, if there are events in the queue, they will
 *      all be processed before returning
 *
 *   a return of true means that the app must exit
 *
 ***********************************************************************/
// from ScanMgrDef.h
typedef enum tagScanMgrEvent
{
    scanDecodeEvent	= 0x7fff+0x800,	// A decode has finished (valid or invalid decode)
    scanBatteryErrorEvent,					// Battery too low to perform scan
    scanTriggerEvent 						// A scan attempt was initiated - hard or soft trigger
} ScanMgrEvent;

EventType lastEvent;
bool bHookHard = false, bHookMenu = false, bHookSilk = false, bHookSync = false;
extern long atexit_func;

bool UIYield(long time) {
    short eventQ, eventQv1, eventQv2;
    Word error;
    bool justOne = (time != 0);
    if (time == 1)
        time = -1;
    ULong start = TimGetTicks(), currTime;
    
    if (killEvents)
        return false;
    do {
dumb_event:
        if (time == -1 || time == 0)
            EvtGetEvent(&lastEvent, time);
        else {
            currTime = TimGetTicks();
            if (currTime - start >= time)
                return false; // time has expired
            EvtGetEvent(&lastEvent, time - (currTime - start));
        }
    
        if (lastEvent.eType==nilEvent) {
            if (!justOne)
                return false;
            else
                goto dumb_event;
        }

        // check for hard button press
        if (bHookHard && lastEvent.eType==keyDownEvent &&
            lastEvent.data.keyDown.chr >= hard1Chr &&
            lastEvent.data.keyDown.chr <= hard4Chr) goto hook;
            
        if ((bHookMenu || bHookSilk) && lastEvent.eType==keyDownEvent &&
            lastEvent.data.keyDown.chr==menuChr) goto hook;
            
        if (bHookSync && lastEvent.eType==keyDownEvent &&
            lastEvent.data.keyDown.chr==hardCradleChr) goto hook;
            
        if (bHookSilk && lastEvent.eType==keyDownEvent &&
            (lastEvent.data.keyDown.chr == launchChr ||
            lastEvent.data.keyDown.chr == calcChr ||
            lastEvent.data.keyDown.chr == findChr)) goto hook;
            
        if (! SysHandleEvent(&lastEvent))
            if (! MenuHandleEvent(0, &lastEvent, &error))
                if (! AppHandleEvent(&lastEvent))
                    FrmDispatchEvent(&lastEvent);

        if (lastEvent.eType==appStopEvent) {
            EvtAddEventToQueue(&lastEvent); // Put the message back in the Q
            if (atexit_func) {
                killEvents = true;
                CallFunc(atexit_func);
                killVM = true;
            }
            ErrThrow(3); // Throw an exception, get out of app
        }
hook:
        // this event system is so broken... only holding the last event is dumb
        // if we hit a scan decode event, don't overwrite it
        if (lastEvent.eType==scanDecodeEvent) {
            eventQ = 20;
        } else if (lastEvent.eType==scanBatteryErrorEvent) {
            eventQ = 22;
        } else if (lastEvent.eType==scanTriggerEvent) {
            eventQ = 21;
        } else if (lastEvent.eType==penDownEvent) {
            eventQ = 2;
        } else if (lastEvent.eType==penUpEvent) {
            eventQ = 3;
        } else if (lastEvent.eType==penMoveEvent) {
            eventQ = 4;
        } else if (lastEvent.eType==keyDownEvent) {
            if (lastEvent.data.keyDown.chr==pageUpChr) eventQ = 5;
            else if (lastEvent.data.keyDown.chr==pageDownChr) eventQ = 6;
            else if (lastEvent.data.keyDown.chr >= hard1Chr && lastEvent.data.keyDown.chr <= hard4Chr) eventQ = 7 + lastEvent.data.keyDown.chr - hard1Chr;
            else if (lastEvent.data.keyDown.chr==menuChr) eventQ = 11;
            else if (lastEvent.data.keyDown.chr==launchChr) eventQ = 12;
            else if (lastEvent.data.keyDown.chr==findChr) eventQ = 13;
            else if (lastEvent.data.keyDown.chr==calcChr) eventQ = 14;
            else if (lastEvent.data.keyDown.chr==hardCradleChr) eventQ = 15;
            else if (lastEvent.data.keyDown.chr==lowBatteryChr) goto dumb_event;
            else if (lastEvent.data.keyDown.chr==vchrResetAutoOff) goto dumb_event;
            else if (lastEvent.data.keyDown.chr==vchrNavChange) {
                if ((lastEvent.data.keyDown.modifiers & autoRepeatKeyMask) == 0 &&
                    (lastEvent.data.keyDown.keyCode & (navBitsAll | navChangeBitsAll)) == navChangeSelect)
                {
                    // select
                    eventQ = 18;
                } else if (lastEvent.data.keyDown.modifiers & autoRepeatKeyMask) {
                    if ((lastEvent.data.keyDown.keyCode & (navBitsAll | navChangeBitsAll)) == navBitLeft) {
                        eventQ = 16;
                    } else if ((lastEvent.data.keyDown.keyCode & (navBitsAll | navChangeBitsAll)) == navBitRight) {
                        eventQ = 17;
                    }
                } else {
                    if ((lastEvent.data.keyDown.keyCode & (navBitsAll | navChangeBitsAll)) == (navBitLeft | navChangeLeft)) {
                        eventQ = 16;
                    } else if ((lastEvent.data.keyDown.keyCode & (navBitsAll | navChangeBitsAll)) == (navBitRight | navChangeRight)) {
                        eventQ = 17;
                    }
                }
            } else if (lastEvent.data.keyDown.chr==vchrRockerCenter) {
                eventQ = 18;
            } else if (lastEvent.data.keyDown.chr==vchrRockerLeft) {
                eventQ = 16;
            } else if (lastEvent.data.keyDown.chr==vchrRockerRight) {
                eventQ = 17;
            } else {
                eventQ = 1; // TODO filter
            }
            eventQv1 = lastEvent.data.keyDown.chr; // TODO filter
        } else if (enableResize && (lastEvent.eType == winDisplayChangedEvent || lastEvent.eType == frmOpenEvent)) {
            // generate display change for open event
            eventQ = 24;
            WinGetDisplayExtent(&eventQv1, &eventQv2);
        } else {
            goto noevent;
        }
            
        if (eventQ <= 4 && eventQ >= 2) {
            eventQv1 = lastEvent.screenX;
            eventQv2 = lastEvent.screenY;
            //if (eventQv2 >= 160) eventQ=0;
        }
        
        eventQueue.AddEvent(eventQ, eventQv1, eventQv2);
        
noevent:
        //if (stopApp) return true;
        // TODO: not sure this is needed!
        if (killVM) {
            ErrThrow(3);
        }
        if (justOne)
            return false;
    } while (true);
}

/***********************************************************************
 *
 * FUNCTION:     AppStart
 *
 ***********************************************************************/
void randomize(long);
UInt32 romVersion;
UInt32 density;
bool bHasColor = false;
bool bHighDensity = false;
static Err AppStart(void)
{
    FtrGet(sysFtrCreator, sysFtrNumROMVersion, &romVersion);
    UInt32 wver = 0;
    FtrGet(sysFtrCreator, sysFtrNumWinVersion, &wver);
    if (romVersion >= ver50 || wver >= 4) {
        WinScreenGetAttribute(winScreenDensity, &density);
        bHighDensity = true;
    } else {
        density = 72;
    }
    if (romVersion >= ver35) {
        bHasColor = true;
    }
    
#ifndef POCKETC_FAT
    pvNames	= new vector<char*>(true);
#endif
#ifndef	POCKETC_RUNTIME
    pvAppNames = new vector<char*>(true);
#endif
    
    Err	error= 0;
    UInt mode;
    SystemPreferencesType sysPrefs;
    Word prefsSize;

    char name[41];
    *name =	'\0';
    DlkGetSyncInfo(NULL, NULL, NULL, name, NULL, NULL);
    //if (!*name) strcpy(name, "copilot");
    
    // Determime if	secert record should be	shown.
    PrefGetPreferences(&sysPrefs);
    HideSecretRecords =	sysPrefs.hideSecretRecords;
    if (sysPrefs.hideSecretRecords)	mode = dmModeReadWrite;
    else mode =	dmModeReadWrite	| dmModeShowSecret;
    
    // Find	the	application's data file.  If it	doesn't	exist create it.
    PcDB = DmOpenDatabaseByTypeCreator(appDBType, appFileCreator, mode);
    if (!PcDB) {
        error =	DmCreateDatabase(0,	appDBName, appFileCreator, appDBType, false);
        if (error) return error;

        PcDB = DmOpenDatabaseByTypeCreator(appDBType, appFileCreator, mode);
        if (!PcDB) return 1;

        error =	PcAppInfoInit(PcDB);
        if (error) return error;
    }
    
    // Time	expiration stuff
    prefsSize =	sizeof(firstUsed);
#ifndef	POCKETC_RETAIL
    if (PrefGetAppPreferences('DVci', appPrefID, &firstUsed, &prefsSize, true)==noPreferenceFound || (!firstUsed)) {
        firstUsed =	TimGetSeconds();
        PrefSetAppPreferences('DVci', appPrefID, appPrefVersionNum,	&firstUsed,	sizeof(firstUsed), true);
    }
#else
    firstUsed =	0;
    PrefSetAppPreferences('PktB', appPrefID, appPrefVersionNum,	&firstUsed,	sizeof(firstUsed), true);
    firstUsed =	TimGetSeconds();
#endif

    // Read	the	preferences	/ saved-state information.	There is only one
    // version of the Applications preferences so don't	worry about	multiple
    // versions.
    prefsSize =	sizeof(PcPreferenceType);
    MemSet(&prefs, sizeof(PcPreferenceType), 0);
    // We don't	care if	the	prefs aren't found
    short ver =	PrefGetAppPreferences(appFileCreator, appPrefID, &prefs, &prefsSize, true);
    //if (ver == noPreferenceFound || prefsSize	< sizeof(PcPreferenceType))	{
    //	prefs.lastApp[0] = 0;
    //}

    // if memo app is not specified, get it
    if (prefs.memoApp[0] ==	0) {
        DmSearchStateType ss;
        UInt16 card;
        LocalID	lid;
        Err	err	= DmGetNextDatabaseByTypeCreator(true, &ss,	'appl',	'memo',	true, &card, &lid);
        if (err	== 0 &&	lid) DmDatabaseInfo(card, lid, prefs.memoApp, 0,0,0,0,0,0,0,0,0,0);
    }
    if (prefs.docApp[0]	== 0) {
        strcpy(prefs.docApp, "<none>");
    }
    prefs.registered = false;
    
    // Check registration number
    preCalcRegCode = genCode(name);
    if (!*name || preCalcRegCode==prefs.regCode) prefs.registered =	true;
    else prefs.registered =	false;
    
    Err	merror;
    merror = SysLibFind(MathLibName, &MathLibRef);
    if (merror == sysErrLibNotFound)
        merror = SysLibLoad(LibType, MathLibCreator, &MathLibRef);
    mathLibLoaded =	(merror	== 0);
    if (mathLibLoaded) {
        merror = MathLibOpen(MathLibRef, MathLibVersion);
        if (merror)	mathLibLoaded =	false;
    }
    if (SysLibFind("Serial Library", &SerLibRef)) SerLibRef=0;
        
    if (DmNumRecords(PcDB) < 1)	{
        // Output is not there,	create it
        UInt index = 0;
        VoidHand h = DmNewRecord(PcDB, &index, 1);
        VoidPtr	p =	MemHandleLock(h);
        DmSet(p, 0,	1, 0);
        MemHandleUnlock(h);			
        DmReleaseRecord(PcDB, 0, true);
    }
    
    if (DmNumRecords(PcDB) > 1)	{
        for	(short i=DmNumRecords(PcDB)-1; i>=1; i--) {
            DmRemoveRecord(PcDB, i);
        }
    }
    
    output = (Handle)DmGetRecord(PcDB, 0);
    
    InitDIA();

    return error;
}

/***********************************************************************
 *
 * FUNCTION:    AppStop
 *
 ***********************************************************************/
static void AppStop(void) {
    FrmCloseAllForms();
    PrefSetAppPreferences(appFileCreator, appPrefID, appPrefVersionNum,
        &prefs, sizeof(prefs), true);
    DmReleaseRecord(PcDB, 0, true);
    DmCloseDatabase(PcDB);

    UInt usecount;
    if (mathLibLoaded) {
        MathLibClose(MathLibRef, &usecount);
        //ErrFatalDisplayIf(error, "Can't close MathLib");
        if (usecount == 0) SysLibRemove(MathLibRef);
    }
    
#ifndef POCKETC_FAT
    delete pvNames;
#endif
#ifndef POCKETC_RUNTIME
    delete pvAppNames;
#endif
    CloseDIA();
}

/***********************************************************************
 * FUNCTION:    PilotMain
 *
 * DESCRIPTION: This is the main entry point for the application.
 *
 * PARAMETERS:  cmd - word value specifying the launch code. 
 *              cmdPB - pointer to a structure that is associated with the launch code. 
 *              launchFlags -  word value providing extra information about the launch.
 *
 * RETURNED:    Result of launch
 *
 ***********************************************************************/
DWord PilotMain(Word cmd, Ptr cmdPBP, Word launchFlags) {
    Err	error;

    error =	RomVersionCompatible(version20,	launchFlags);
    if (error) return error;

    switch (cmd) {
        case sysAppLaunchCmdNormalLaunch:
#ifdef POCKETC_FAT
            error =	AppStart();
            if (error) return error;
            
            //FrmGotoForm(MainForm);
            UIYield(false);	// Process the form	change before we start playing
            bLaunchApp = true;
            Execute(NULL);
            AppStop();
            if (bForceExit) {
                if (romVersion >= 0x03003000) {   
                    EventType event;
                    event.eType=keyDownEvent;
                    event.data.keyDown.chr=launchChr;
                    event.data.keyDown.keyCode=launchChr;
                    event.data.keyDown.modifiers=commandKeyMask;
                    SysHandleEvent(&event); // Put the message back in the Q
                } else {
                    AppLaunchWithCommand(sysFileCDefaultApp, sysAppLaunchCmdNormalLaunch, NULL);
                }
            }

#else
            error =	AppStart();
            if (error) return error;
            
            //if (prefs.currentForm==FTMain)
            FrmGotoForm(MainForm);
            //else FrmGotoForm(OutputForm);
            AppEventLoop();
            AppStop();
#endif
            break;
        case sysAppLaunchCmdSaveData:
            FrmSaveAllForms();
            break;
        case sysAppLaunchCmdSystemReset:
            if (((SysAppLaunchCmdSystemResetType*)cmdPBP)->createDefaultDB)	{
                Handle resH;

                resH = (Handle)DmGet1Resource(sysResTDefaultDB,	sysResIDDefaultDB);
                if (resH) {
                    DmCreateDatabaseFromImage((char*)MemHandleLock(resH));
                    MemHandleUnlock(resH);
                    DmReleaseResource(resH);
                }
            }
            break;
        case sysAppLaunchCmdSyncNotify:	{
        //case sysAppLaunchCmdSyncRequest: {
            DmSearchStateType ss;
            LocalID	lid;
            UInt attr, card;
            if (!DmGetNextDatabaseByTypeCreator(true, &ss, appVMDBType,	appFileCreator,	false, &card, &lid)) {
                do {
                    DmDatabaseInfo(card, lid, 0, &attr,	0,0,0,0,0,0,0,0,0);
                    if (attr & dmHdrAttrBackup)	{
                        attr &=	~dmHdrAttrBackup;
                     if	(!(attr	& (dmHdrAttrReadOnly | dmHdrAttrOpen)))
                         DmSetDatabaseInfo(card, lid, 0, &attr,	0,0,0,0,0,0,0,0,0);
                    }
                } while	(!DmGetNextDatabaseByTypeCreator(false,	&ss, appVMDBType, appFileCreator, false, &card,	&lid));
            }
            break;
        }
        
        case sysAppLaunchCmdStartApplet: {
            error =	AppStart();
            if (error) return error;
            
            //FrmGotoForm(MainForm);
            UIYield(false);	// Process the form	change before we start playing
            bLaunchApp = true;
            Execute((char*)cmdPBP);
            AppStop();
            if (bForceExit) {
                if (romVersion >= 0x03003000) {   
                    EventType event;
                    event.eType=keyDownEvent;
                    event.data.keyDown.chr=launchChr;
                    event.data.keyDown.keyCode=launchChr;
                    event.data.keyDown.modifiers=commandKeyMask;
                    SysHandleEvent(&event); // Put the message back in the Q
                } else {
                    AppLaunchWithCommand(sysFileCDefaultApp, sysAppLaunchCmdNormalLaunch, NULL);
                }
            }
            break;
        }
        
#ifndef	POCKETC_RUNTIME
        case sysAppLaunchCmdCompile: {
            error =	AppStart();
            if (error) return error;
            // open	compile	form
            FrmGotoForm(CompileForm);
            UIYield(false);
            // select the specified	file
            bool found = false;
            int	i =	0;
            for	(;i<vNames.size();i++) {
                if (strcmp(vNames[i], (char*)cmdPBP) ==	0) {
                    LstSetSelection((ListPtr)GetObjectPtr(CompileMemoList),	i);
                    found =	true;
                    break;
                }
            }
            // compile
            if (found) {
                strncpy(prefs.lastApp, vNames[i], 32);
                prefs.lastApp[31] =	0;
                Compile(i);
                vNames.clear();
                vNumFromList.clear();
            } else {
                Alert("Unable to find specified	file");
            }
            // continue	app	execution
            AppEventLoop();
            AppStop();
            break;
        }
#endif		  
        case sysAppLaunchCmdNotify:
            HandleResizeNotification(((SysNotifyParamType*)cmdPBP)->notifyType);
            break;
            
        default:
            break;
    }
    return 0;
}

char* funcFromLoc(long loc) {
    if (dbgLoc) {
        short nFuncs = getCode(dbgLoc) * 256 + getCode(dbgLoc+1);
        short iFunc = 0;
        long addr = dbgLoc+2;
        long offset = 0x0fffffff;
        for (short i=0;i<nFuncs;i++) {
            long floc;
            if (appVer >= 0x0500) {
                floc = ((ULong)getCode(addr) << 24) + ((ULong)getCode(addr+1) << 16) + ((ULong)getCode(addr+2) << 8) + (ULong)getCode(addr+3);
            } else {
                floc = getCode(addr) * 256 + getCode(addr+1);
            }
            if (floc <= loc && loc-floc < offset) {
                iFunc = i;
                offset = loc-floc;
            }
            addr += (appVer >= 0x0500) ? 6 : 4;
        }
        addr = dbgLoc + (iFunc + 1) * ((appVer >= 0x0500) ? 6 : 4);
        unsigned short strLoc = getCode(addr) * 256 + getCode(addr+1);
        return &cStrings[strLoc];
    }
    return NULL;
}

#ifndef POCKETC_FAT
void vm_error(char* m, unsigned short pc) {
    long loc = fullAddr(pc);
    char* name = funcFromLoc(loc);
    if (name)
        StrPrintF(msg, "Addr: %li\nFunc: %s\n%s", loc, name, m);
    else
        StrPrintF(msg, "Addr: %li\n%s", loc, m);
    FrmCustomAlert(VMErrorAlert, msg, "", "");
    // cleanup VM
    bForceExit = true;
    ErrThrow(2);
}
#endif

void vm_warn(char* m, unsigned short pc) {
    //char msg[256];
    
    StrPrintF(msg, "ByteCode: %d\n%s", pc, m);
    short res = FrmCustomAlert(VMWarnAlert, msg, "", "");
    // cleanup VM
    if (res) ErrThrow(2);
}

